<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Parlay Builder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üèà</text></svg>" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500;600;700&family=Source+Sans+3:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.min.js"></script>
  <script src="odds-engine.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg-deep: #030712;
      --bg-card: #0c1322;
      --bg-hover: #111827;
      --bg-selected: #1e3a5f;
      --text-primary: #f1f5f9;
      --text-secondary: #94a3b8;
      --text-muted: #64748b;
      --border: #1e293b;
      --accent: #3b82f6;
      --positive: #22c55e;
      --negative: #ef4444;
      --warning: #d97706;
      --purple: #a855f7;
    }

    body {
      font-family: 'Source Sans 3', system-ui, sans-serif;
      background: var(--bg-deep);
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.5;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1.5rem 1rem 2rem;
    }

    header { text-align: center; margin-bottom: 1.5rem; }

    h1 {
      font-family: 'Oswald', sans-serif;
      font-size: 1.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.02em;
      margin-bottom: 0.25rem;
    }

    .subtitle { font-size: 0.9rem; color: var(--text-secondary); }

    .back-link {
      display: inline-block;
      color: var(--accent);
      text-decoration: none;
      font-size: 0.9rem;
      margin-bottom: 1rem;
    }
    .back-link:hover { text-decoration: underline; }

    .layout {
      display: grid;
      grid-template-columns: 1fr 350px;
      gap: 1.5rem;
    }

    @media (max-width: 900px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }

    .section {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 1rem;
      margin-bottom: 1rem;
    }

    .section-title {
      font-family: 'Oswald', sans-serif;
      font-size: 1rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .matchup-select {
      width: 100%;
      background: var(--bg-deep);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      padding: 0.75rem 1rem;
      font-family: inherit;
      font-size: 1rem;
      cursor: pointer;
      margin-bottom: 1rem;
    }

    .matchup-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    .legs-container {
      max-height: 60vh;
      overflow-y: auto;
    }

    .leg-group {
      margin-bottom: 1rem;
    }

    .leg-group-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--accent);
      margin-bottom: 0.5rem;
      padding-bottom: 0.25rem;
      border-bottom: 1px solid var(--border);
    }

    .leg-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.6rem 0.75rem;
      background: var(--bg-deep);
      border: 1px solid var(--border);
      border-radius: 6px;
      margin-bottom: 0.5rem;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .leg-item:hover {
      border-color: var(--accent);
      background: var(--bg-hover);
    }

    .leg-item.selected {
      border-color: var(--positive);
      background: rgba(34, 197, 94, 0.1);
    }

    .leg-item.selected .leg-checkbox {
      background: var(--positive);
      border-color: var(--positive);
    }

    .leg-checkbox {
      width: 18px;
      height: 18px;
      border: 2px solid var(--border);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      font-size: 0.75rem;
      color: white;
    }

    .leg-info {
      flex: 1;
      min-width: 0;
    }

    .leg-name {
      font-weight: 500;
      font-size: 0.9rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .leg-detail {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .leg-odds {
      font-family: 'Oswald', sans-serif;
      font-size: 0.95rem;
      font-weight: 500;
      color: var(--positive);
      white-space: nowrap;
    }

    .leg-prob {
      font-size: 0.75rem;
      color: var(--text-muted);
      text-align: right;
    }

    /* Parlay slip (right side) */
    .parlay-slip {
      position: sticky;
      top: 1rem;
    }

    .slip-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .clear-btn {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      padding: 0.35rem 0.75rem;
      border-radius: 4px;
      font-size: 0.8rem;
      cursor: pointer;
    }

    .clear-btn:hover {
      border-color: var(--negative);
      color: var(--negative);
    }

    .slip-legs {
      margin-bottom: 1rem;
    }

    .slip-leg {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
      border-bottom: 1px solid var(--border);
      font-size: 0.85rem;
    }

    .slip-leg:last-child {
      border-bottom: none;
    }

    .slip-leg-name {
      flex: 1;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-right: 0.5rem;
    }

    .slip-leg-odds {
      font-family: 'Oswald', sans-serif;
      color: var(--positive);
    }

    .slip-leg-remove {
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0.25rem;
      margin-left: 0.5rem;
    }

    .slip-leg-remove:hover {
      color: var(--negative);
    }

    .slip-empty {
      text-align: center;
      color: var(--text-muted);
      padding: 2rem 1rem;
      font-size: 0.9rem;
    }

    .slip-summary {
      background: var(--bg-deep);
      border-radius: 8px;
      padding: 1rem;
      margin-top: 1rem;
    }

    .summary-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    .summary-row:last-child {
      margin-bottom: 0;
    }

    .summary-label {
      color: var(--text-secondary);
    }

    .summary-value {
      font-weight: 600;
    }

    .summary-value.highlight {
      color: var(--positive);
      font-family: 'Oswald', sans-serif;
      font-size: 1.1rem;
    }

    .summary-value.warning {
      color: var(--warning);
    }

    .prob-bar {
      height: 6px;
      background: var(--bg-hover);
      border-radius: 3px;
      margin: 0.5rem 0;
      overflow: hidden;
    }

    .prob-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--positive), var(--warning));
      border-radius: 3px;
      transition: width 0.3s ease;
    }

    .wager-input {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 1rem;
    }

    .wager-input label {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .wager-input input {
      flex: 1;
      background: var(--bg-deep);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      padding: 0.5rem;
      font-family: inherit;
      font-size: 0.9rem;
      width: 80px;
    }

    .wager-input input:focus {
      outline: none;
      border-color: var(--accent);
    }

    /* Suggested parlays */
    .suggested-section {
      margin-top: 1.5rem;
    }

    .suggested-parlay {
      background: var(--bg-deep);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.75rem;
      margin-bottom: 0.75rem;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .suggested-parlay:hover {
      border-color: var(--accent);
    }

    .suggested-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .suggested-name {
      font-weight: 600;
      font-size: 0.9rem;
    }

    .suggested-odds {
      font-family: 'Oswald', sans-serif;
      color: var(--positive);
    }

    .suggested-legs {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .suggested-prob {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-top: 0.25rem;
    }

    .loading {
      text-align: center;
      color: var(--text-muted);
      padding: 2rem;
    }

    .no-data {
      text-align: center;
      color: var(--text-muted);
      padding: 1.5rem;
      font-size: 0.9rem;
    }

    /* Correlation warning */
    .correlation-warning {
      background: rgba(217, 119, 6, 0.1);
      border: 1px solid var(--warning);
      border-radius: 6px;
      padding: 0.75rem;
      margin-top: 1rem;
      font-size: 0.85rem;
      color: var(--warning);
    }

    /* Matchup indicators */
    .matchup-badge {
      display: inline-block;
      font-size: 0.65rem;
      font-weight: 600;
      text-transform: uppercase;
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      margin-left: 0.5rem;
    }
    .matchup-badge.smash {
      background: rgba(34, 197, 94, 0.2);
      color: var(--positive);
    }
    .matchup-badge.tough {
      background: rgba(239, 68, 68, 0.2);
      color: var(--negative);
    }
    .matchup-badge.neutral {
      background: rgba(148, 163, 184, 0.15);
      color: var(--text-muted);
    }

    /* Trend indicators */
    .trend-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.2rem;
      font-size: 0.65rem;
      font-weight: 600;
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      margin-left: 0.25rem;
    }
    .trend-badge.hot {
      background: rgba(239, 68, 68, 0.15);
      color: #f97316;
    }
    .trend-badge.cold {
      background: rgba(59, 130, 246, 0.15);
      color: #3b82f6;
    }

    /* Confidence indicator */
    .confidence-badge {
      display: inline-block;
      font-size: 0.6rem;
      font-weight: 700;
      padding: 0.1rem 0.35rem;
      border-radius: 3px;
      margin-left: 0.25rem;
      background: rgba(168, 85, 247, 0.2);
      color: var(--purple);
    }

    /* Correlation details */
    .correlation-details {
      background: var(--bg-deep);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.75rem;
      margin-top: 0.75rem;
      font-size: 0.8rem;
    }
    .correlation-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.35rem 0;
      border-bottom: 1px solid var(--border);
    }
    .correlation-row:last-child { border-bottom: none; }
    .correlation-boost {
      color: var(--positive);
      font-weight: 600;
    }
    .correlation-conflict {
      color: var(--negative);
      font-weight: 600;
    }

    /* H2H context */
    .h2h-context {
      background: rgba(59, 130, 246, 0.1);
      border: 1px solid var(--accent);
      border-radius: 6px;
      padding: 0.6rem 0.75rem;
      margin-bottom: 0.75rem;
      font-size: 0.8rem;
    }
    .h2h-context-title {
      font-weight: 600;
      color: var(--accent);
      margin-bottom: 0.25rem;
    }
    .h2h-context-stat {
      color: var(--text-secondary);
    }
    .h2h-context-stat span {
      color: var(--text-primary);
      font-weight: 500;
    }

    /* Leg detail enhancement */
    .leg-detail {
      font-size: 0.8rem;
      color: var(--text-muted);
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.25rem;
    }

    /* Market odds input in slip */
    .slip-leg-market {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      margin-top: 0.25rem;
      font-size: 0.75rem;
    }
    .slip-leg-market label {
      color: var(--text-muted);
    }
    .slip-leg-market input {
      width: 60px;
      background: var(--bg-deep);
      border: 1px solid var(--border);
      border-radius: 3px;
      color: var(--text-primary);
      padding: 0.2rem 0.35rem;
      font-family: inherit;
      font-size: 0.75rem;
      text-align: center;
    }
    .slip-leg-market input:focus {
      outline: none;
      border-color: var(--accent);
    }
    .edge-indicator {
      font-weight: 600;
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
      font-size: 0.7rem;
    }
    .edge-indicator.positive {
      background: rgba(34, 197, 94, 0.15);
      color: var(--positive);
    }
    .edge-indicator.negative {
      background: rgba(239, 68, 68, 0.15);
      color: var(--negative);
    }

    /* Prop evaluator cards */
    .prop-card {
      background: var(--bg-deep);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.75rem;
      margin-bottom: 0.75rem;
    }
    .prop-card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 0.5rem;
    }
    .prop-player-name {
      font-weight: 600;
      font-size: 0.95rem;
    }
    .prop-stat-type {
      font-size: 0.8rem;
      color: var(--text-secondary);
    }
    .prop-badges {
      display: flex;
      gap: 0.25rem;
    }
    .prop-stats-row {
      display: flex;
      gap: 1rem;
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-bottom: 0.6rem;
    }
    .prop-stats-row span {
      color: var(--text-secondary);
    }
    .prop-inputs {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      margin-bottom: 0.6rem;
      flex-wrap: wrap;
    }
    .prop-input-group {
      display: flex;
      align-items: center;
      gap: 0.3rem;
    }
    .prop-input-group label {
      font-size: 0.75rem;
      color: var(--text-muted);
    }
    .prop-input-group input {
      width: 60px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      padding: 0.4rem 0.5rem;
      font-family: inherit;
      font-size: 0.85rem;
      text-align: center;
    }
    .prop-input-group input:focus {
      outline: none;
      border-color: var(--accent);
    }
    .prop-input-group input.line-input {
      width: 70px;
    }
    .prop-odds-row {
      display: flex;
      gap: 0.75rem;
      width: 100%;
      margin-top: 0.25rem;
    }
    .prop-results {
      display: flex;
      gap: 0.5rem;
    }
    .prop-bet-option {
      flex: 1;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.5rem;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .prop-bet-option:hover {
      border-color: var(--accent);
    }
    .prop-bet-option.selected {
      border-color: var(--positive);
      background: rgba(34, 197, 94, 0.1);
    }
    .prop-bet-option.has-edge {
      border-color: var(--positive);
    }
    .prop-bet-label {
      font-weight: 600;
      font-size: 0.85rem;
      margin-bottom: 0.2rem;
    }
    .prop-bet-prob {
      font-size: 0.8rem;
      color: var(--text-secondary);
    }
    .prop-bet-edge {
      font-size: 0.75rem;
      font-weight: 600;
      margin-top: 0.2rem;
    }
    .prop-bet-edge.positive { color: var(--positive); }
    .prop-bet-edge.negative { color: var(--negative); }
    .prop-no-line {
      font-size: 0.8rem;
      color: var(--text-muted);
      font-style: italic;
    }

    /* Filter bar */
    .filter-bar {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
      flex-wrap: wrap;
    }
    .filter-select {
      background: var(--bg-deep);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      padding: 0.4rem 0.6rem;
      font-family: inherit;
      font-size: 0.8rem;
      cursor: pointer;
      min-width: 100px;
    }
    .filter-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    /* Superlative props */
    .superlative-card {
      background: var(--bg-deep);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.75rem;
      margin-bottom: 0.75rem;
    }
    .superlative-title {
      font-weight: 600;
      font-size: 0.95rem;
      margin-bottom: 0.5rem;
      color: var(--accent);
    }
    .superlative-options {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .superlative-option {
      flex: 1;
      min-width: 120px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.5rem;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .superlative-option:hover {
      border-color: var(--accent);
    }
    .superlative-option.selected {
      border-color: var(--positive);
      background: rgba(34, 197, 94, 0.1);
    }
    .superlative-option.has-edge {
      border-color: var(--positive);
    }
    .superlative-player {
      font-weight: 500;
      font-size: 0.85rem;
    }
    .superlative-team {
      font-size: 0.7rem;
      color: var(--text-muted);
    }
    .superlative-prob {
      font-size: 0.8rem;
      color: var(--text-secondary);
      margin-top: 0.25rem;
    }
    .superlative-odds-input {
      width: 55px;
      background: var(--bg-deep);
      border: 1px solid var(--border);
      border-radius: 3px;
      color: var(--text-primary);
      padding: 0.2rem 0.3rem;
      font-size: 0.75rem;
      text-align: center;
      margin-top: 0.25rem;
    }
    .superlative-edge {
      font-size: 0.7rem;
      font-weight: 600;
      margin-top: 0.2rem;
    }
    .superlative-edge.positive { color: var(--positive); }
    .superlative-edge.negative { color: var(--negative); }
  </style>
</head>
<body>
  <div class="container">
    <a href="index.html" class="back-link">&larr; Back to Home</a>

    <header>
      <h1>Parlay Builder</h1>
      <p class="subtitle">Build multi-leg parlays with game and player props</p>
    </header>

    <div class="layout">
      <div class="main-content">
        <div class="section">
          <div class="section-title">Select Matchup</div>
          <select id="matchup-select" class="matchup-select">
            <option value="">Loading matchups...</option>
          </select>
        </div>

        <div id="legs-section" class="section" style="display: none;">
          <div class="section-title">Available Legs</div>
          <div class="filter-bar">
            <select id="filter-type" class="filter-select">
              <option value="all">All Types</option>
              <option value="game">Game Lines</option>
              <option value="superlative">Superlatives</option>
              <option value="props">Player Props</option>
            </select>
            <select id="filter-team" class="filter-select">
              <option value="all">All Teams</option>
            </select>
            <select id="filter-stat" class="filter-select">
              <option value="all">All Stats</option>
              <option value="passing">Passing</option>
              <option value="rushing">Rushing</option>
              <option value="receiving">Receiving</option>
            </select>
          </div>
          <div id="legs-container" class="legs-container">
            <div class="loading">Select a matchup to see available legs</div>
          </div>
        </div>

        <div id="suggested-section" class="section suggested-section" style="display: none;">
          <div class="section-title">Suggested Parlays</div>
          <div id="suggested-container"></div>
        </div>
      </div>

      <div class="parlay-slip section">
        <div class="slip-header">
          <div class="section-title" style="margin-bottom: 0;">Parlay Slip</div>
          <button id="clear-btn" class="clear-btn">Clear</button>
        </div>

        <div id="slip-legs" class="slip-legs">
          <div class="slip-empty">Add 2+ legs to build a parlay</div>
        </div>

        <div id="slip-summary" class="slip-summary" style="display: none;">
          <div class="summary-row">
            <span class="summary-label">Legs</span>
            <span id="leg-count" class="summary-value">0</span>
          </div>
          <div class="summary-row">
            <span class="summary-label">Combined Odds</span>
            <span id="combined-odds" class="summary-value highlight">+100</span>
          </div>
          <div class="summary-row">
            <span class="summary-label">Win Probability</span>
            <span id="win-prob" class="summary-value">50%</span>
          </div>
          <div class="prob-bar">
            <div id="prob-fill" class="prob-fill" style="width: 50%;"></div>
          </div>
          <div class="wager-input">
            <label>Wager $</label>
            <input type="number" id="wager-amount" value="10" min="1">
            <span class="summary-label">To win:</span>
            <span id="potential-win" class="summary-value highlight">$10</span>
          </div>
        </div>

        <div id="correlation-warning" class="correlation-warning" style="display: none;">
          Correlated legs detected. Actual probability may differ.
        </div>
      </div>
    </div>
  </div>

  <script>
    let db = null;
    let currentMatchup = null;
    let selectedLegs = [];
    let availableLegs = [];  // Moneyline legs only now
    let propCards = [];      // Player prop cards with editable lines
    let superlativeCards = []; // Superlative props (most passing yards, etc.)
    let defenseRankings = {};  // position -> stat -> { team: rank }
    let h2hData = null;
    let marketOdds = {};  // legId -> market odds entered by user
    let propInputs = {};  // propId -> { line, overOdds, underOdds } user inputs
    let gameInputs = {};  // spread/total inputs from user
    let superlativeInputs = {}; // superlativeId -> playerId -> odds
    let modelOdds = null; // Store model's predicted spread/total

    // Filter state
    let filters = {
      type: 'all',
      team: 'all',
      stat: 'all'
    };

    async function initDB() {
      const SQL = await initSqlJs({
        locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}`
      });

      const response = await fetch('nfl.db?' + Date.now());
      const buffer = await response.arrayBuffer();
      db = new SQL.Database(new Uint8Array(buffer));

      // Load advanced stats for odds engine
      await OddsEngine.loadAdvancedStats(2025);

      // Calculate defense rankings
      calculateDefenseRankings();

      loadMatchups();
    }

    function calculateDefenseRankings() {
      // Calculate how much each defense allows by position/stat
      // Lower rank = tougher defense, Higher rank = easier matchup
      const stats = ['pass_yd', 'rush_yd', 'rec_yd', 'rec'];
      const positions = ['QB', 'RB', 'WR', 'TE'];

      positions.forEach(pos => {
        defenseRankings[pos] = {};
        stats.forEach(stat => {
          defenseRankings[pos][stat] = {};
        });
      });

      // Query average stats allowed by each defense, grouped by position
      const result = db.exec(`
        SELECT
          opponent as team,
          position,
          AVG(pass_yd) as avg_pass_yd,
          AVG(rush_yd) as avg_rush_yd,
          AVG(rec_yd) as avg_rec_yd,
          AVG(rec) as avg_rec,
          COUNT(DISTINCT player_id) as players
        FROM player_weekly_stats
        WHERE season = 2025 AND position IN ('QB', 'RB', 'WR', 'TE')
        GROUP BY opponent, position
        HAVING players >= 3
      `);

      if (!result.length) return;

      const cols = result[0].columns;
      const byPosTeam = {};

      result[0].values.forEach(vals => {
        const row = {};
        cols.forEach((c, i) => row[c] = vals[i]);
        const key = `${row.position}_${row.team}`;
        byPosTeam[key] = row;
      });

      // Rank each team for each position/stat
      positions.forEach(pos => {
        stats.forEach(stat => {
          const teams = Object.values(byPosTeam)
            .filter(r => r.position === pos && r[`avg_${stat}`] != null)
            .sort((a, b) => (b[`avg_${stat}`] || 0) - (a[`avg_${stat}`] || 0)); // Higher allowed = easier

          teams.forEach((t, idx) => {
            defenseRankings[pos][stat][t.team] = {
              rank: idx + 1,
              allowed: t[`avg_${stat}`],
              total: teams.length
            };
          });
        });
      });
    }

    function getMatchupQuality(position, stat, opponent) {
      if (!defenseRankings[position] || !defenseRankings[position][stat]) return null;

      const data = defenseRankings[position][stat][opponent];
      if (!data) return null;

      const pct = data.rank / data.total;  // Lower = easier (allows more)
      return {
        rank: data.rank,
        total: data.total,
        quality: pct <= 0.25 ? 'smash' : pct >= 0.75 ? 'tough' : 'neutral',
        allowed: data.allowed
      };
    }

    function getPlayerTrend(playerName) {
      // Get last 3 games and compare to season average
      const result = db.exec(`
        SELECT
          pts_ppr,
          week,
          (SELECT AVG(pts_ppr) FROM player_weekly_stats WHERE player_name = p.player_name AND season = 2025) as season_avg
        FROM player_weekly_stats p
        WHERE player_name = '${playerName.replace(/'/g, "''")}' AND season = 2025
        ORDER BY week DESC
        LIMIT 3
      `);

      if (!result.length || result[0].values.length < 3) return null;

      const cols = result[0].columns;
      const games = result[0].values.map(vals => {
        const obj = {};
        cols.forEach((c, i) => obj[c] = vals[i]);
        return obj;
      });

      const last3Avg = games.reduce((s, g) => s + (g.pts_ppr || 0), 0) / games.length;
      const seasonAvg = games[0].season_avg || 0;

      if (seasonAvg === 0) return null;

      const diff = (last3Avg - seasonAvg) / seasonAvg;
      if (diff >= 0.15) return { trend: 'hot', pct: diff };
      if (diff <= -0.15) return { trend: 'cold', pct: diff };
      return null;
    }

    function loadH2HContext(home, away) {
      // Get historical matchup data for game totals context
      const result = db.exec(`
        SELECT
          home_score + away_score as total,
          home_score,
          away_score,
          season,
          week
        FROM games
        WHERE ((home_team = '${home}' AND away_team = '${away}')
           OR (home_team = '${away}' AND away_team = '${home}'))
          AND is_completed = 1
        ORDER BY season DESC, week DESC
        LIMIT 10
      `);

      if (!result.length || !result[0].values.length) {
        h2hData = null;
        return;
      }

      const cols = result[0].columns;
      const games = result[0].values.map(vals => {
        const obj = {};
        cols.forEach((c, i) => obj[c] = vals[i]);
        return obj;
      });

      const totals = games.map(g => g.total).filter(t => t > 0);
      const avgTotal = totals.length ? totals.reduce((a, b) => a + b, 0) / totals.length : 0;
      const overCount = totals.filter(t => t > 44).length;  // League avg ~44

      h2hData = {
        games: games.length,
        avgTotal: avgTotal.toFixed(1),
        overRate: totals.length ? ((overCount / totals.length) * 100).toFixed(0) : 0,
        lastGame: games[0]
      };
    }

    function loadMatchups() {
      const result = db.exec(`
        SELECT week, home_team, away_team, game_date
        FROM games
        WHERE season = 2025 AND is_completed = 0
        ORDER BY week, game_date
      `);

      const select = document.getElementById('matchup-select');
      select.innerHTML = '<option value="">Select a matchup...</option>';

      if (result.length && result[0].values) {
        result[0].values.forEach(([week, home, away, date]) => {
          const opt = document.createElement('option');
          opt.value = `${home}|${away}|${week}`;
          opt.textContent = `Week ${week}: ${away} @ ${home}`;
          select.appendChild(opt);
        });
      }
    }

    function loadMatchupData(home, away, week) {
      currentMatchup = { home, away, week };
      availableLegs = [];
      propCards = [];
      superlativeCards = [];
      propInputs = {};
      gameInputs = {};
      superlativeInputs = {};

      // Update team filter options
      const teamFilter = document.getElementById('filter-team');
      teamFilter.innerHTML = `
        <option value="all">All Teams</option>
        <option value="${home}">${home}</option>
        <option value="${away}">${away}</option>
      `;

      // Load H2H context for game totals
      loadH2HContext(home, away);

      // Get team stats
      const homeStats = getTeamStats(home);
      const awayStats = getTeamStats(away);

      // Calculate game odds and store model predictions
      modelOdds = OddsEngine.calculateMatchupOdds(homeStats, awayStats);
      modelOdds.home = home;
      modelOdds.away = away;

      // Build moneyline legs only (spread/total are now editable cards)
      availableLegs = buildMoneylineLegs(home, away, modelOdds);

      // Build player prop cards (with editable lines)
      propCards = buildPropCards(home, away);

      // Build superlative props (most passing yards, most receptions, etc.)
      superlativeCards = buildSuperlativeCards(home, away);

      renderLegs();
      generateSuggestedParlays();
    }

    function getTeamStats(team) {
      const result = db.exec(`
        SELECT * FROM team_stats WHERE team_code = '${team}' AND season = 2025
      `);

      if (result.length && result[0].values.length) {
        const cols = result[0].columns;
        const vals = result[0].values[0];
        const stats = {};
        cols.forEach((col, i) => stats[col] = vals[i]);
        return stats;
      }
      return null;
    }

    function buildMoneylineLegs(home, away, odds) {
      const legs = [];

      // Moneyline only - spread/total are now editable cards
      legs.push({
        id: `ml_${home}`,
        type: 'game',
        category: 'Moneyline',
        name: `${home} to win`,
        detail: `Model: ${(odds.homeWinProb * 100).toFixed(0)}%`,
        odds: odds.homeMoneyline,
        prob: odds.homeWinProb,
        team: home
      });

      legs.push({
        id: `ml_${away}`,
        type: 'game',
        category: 'Moneyline',
        name: `${away} to win`,
        detail: `Model: ${(odds.awayWinProb * 100).toFixed(0)}%`,
        odds: odds.awayMoneyline,
        prob: odds.awayWinProb,
        team: away
      });

      return legs;
    }

    // Calculate spread cover probability given expected margin and market spread
    function calcSpreadProb(expectedMargin, marketSpread, stdDev = 13.5) {
      // expectedMargin: positive = home favored
      // marketSpread: negative = home favored (e.g., -3.5)
      // Home covers if actualMargin > -marketSpread
      // P(cover) = P(margin > -spread) = 1 - normalCDF((-spread - expectedMargin) / stdDev)
      const threshold = -marketSpread;
      const z = (threshold - expectedMargin) / stdDev;
      return 1 - normalCDF(z);
    }

    // Calculate total probability given expected total and market line
    function calcTotalProb(expectedTotal, marketTotal, stdDev = 13) {
      // P(over) = P(actual > marketTotal) = 1 - normalCDF((marketTotal - expectedTotal) / stdDev)
      const z = (marketTotal - expectedTotal) / stdDev;
      return 1 - normalCDF(z);
    }

    function buildPropCards(home, away) {
      const cards = [];

      // Get key players from both teams
      const players = db.exec(`
        SELECT
          player_name,
          team,
          position,
          AVG(pass_yd) as avg_pass_yd,
          AVG(rush_yd) as avg_rush_yd,
          AVG(rec_yd) as avg_rec_yd,
          AVG(rec) as avg_rec,
          SUM(pass_td) as total_pass_td,
          SUM(rush_td) as total_rush_td,
          SUM(rec_td) as total_rec_td,
          COUNT(*) as games,
          STDEV(pass_yd) as std_pass_yd,
          STDEV(rush_yd) as std_rush_yd,
          STDEV(rec_yd) as std_rec_yd,
          STDEV(rec) as std_rec
        FROM player_weekly_stats
        WHERE season = 2025
          AND team IN ('${home}', '${away}')
          AND position IN ('QB', 'RB', 'WR', 'TE')
        GROUP BY player_id
        HAVING games >= 4
        ORDER BY
          team,
          CASE position
            WHEN 'QB' THEN 1
            WHEN 'RB' THEN 2
            WHEN 'WR' THEN 3
            WHEN 'TE' THEN 4
          END,
          (COALESCE(avg_pass_yd, 0) + COALESCE(avg_rush_yd, 0) + COALESCE(avg_rec_yd, 0)) DESC
      `);

      if (!players.length || !players[0].values.length) return cards;

      const cols = players[0].columns;
      players[0].values.forEach(vals => {
        const p = {};
        cols.forEach((col, i) => p[col] = vals[i]);

        if (p.games < 4) return;

        const opponent = p.team === home ? away : home;
        const trend = getPlayerTrend(p.player_name);

        // QB passing yards
        if (p.position === 'QB' && p.avg_pass_yd > 150) {
          const matchup = getMatchupQuality('QB', 'pass_yd', opponent);
          cards.push({
            id: `pass_yd_${p.player_name}`,
            player: p.player_name,
            team: p.team,
            position: p.position,
            stat: 'pass_yd',
            statLabel: 'Pass Yards',
            avg: p.avg_pass_yd,
            std: p.std_pass_yd || 50,
            matchup: matchup,
            trend: trend
          });
        }

        // RB/QB rushing yards
        if ((p.position === 'RB' || p.position === 'QB') && p.avg_rush_yd > 30) {
          const matchup = getMatchupQuality(p.position === 'RB' ? 'RB' : 'QB', 'rush_yd', opponent);
          cards.push({
            id: `rush_yd_${p.player_name}`,
            player: p.player_name,
            team: p.team,
            position: p.position,
            stat: 'rush_yd',
            statLabel: 'Rush Yards',
            avg: p.avg_rush_yd,
            std: p.std_rush_yd || 20,
            matchup: matchup,
            trend: trend
          });
        }

        // Receiving yards
        if (p.avg_rec_yd > 25) {
          const matchup = getMatchupQuality(p.position, 'rec_yd', opponent);
          cards.push({
            id: `rec_yd_${p.player_name}`,
            player: p.player_name,
            team: p.team,
            position: p.position,
            stat: 'rec_yd',
            statLabel: 'Rec Yards',
            avg: p.avg_rec_yd,
            std: p.std_rec_yd || 25,
            matchup: matchup,
            trend: trend
          });
        }

        // Receptions
        if (p.avg_rec > 3) {
          const matchup = getMatchupQuality(p.position, 'rec', opponent);
          cards.push({
            id: `rec_${p.player_name}`,
            player: p.player_name,
            team: p.team,
            position: p.position,
            stat: 'rec',
            statLabel: 'Receptions',
            avg: p.avg_rec,
            std: p.std_rec || 2,
            matchup: matchup,
            trend: trend
          });
        }
      });

      return cards;
    }

    function buildSuperlativeCards(home, away) {
      const cards = [];

      // Get all players with stats for superlative calculations
      const result = db.exec(`
        SELECT
          player_name,
          team,
          position,
          AVG(pass_yd) as avg_pass_yd,
          AVG(rush_yd) as avg_rush_yd,
          AVG(rec_yd) as avg_rec_yd,
          AVG(rec) as avg_rec,
          STDEV(pass_yd) as std_pass_yd,
          STDEV(rush_yd) as std_rush_yd,
          STDEV(rec_yd) as std_rec_yd,
          STDEV(rec) as std_rec,
          COUNT(*) as games
        FROM player_weekly_stats
        WHERE season = 2025
          AND team IN ('${home}', '${away}')
          AND position IN ('QB', 'RB', 'WR', 'TE')
        GROUP BY player_id
        HAVING games >= 4
      `);

      if (!result.length || !result[0].values.length) return cards;

      const cols = result[0].columns;
      const players = result[0].values.map(vals => {
        const p = {};
        cols.forEach((col, i) => p[col] = vals[i]);
        return p;
      });

      // Most Passing Yards (QBs only)
      const qbs = players.filter(p => p.position === 'QB' && p.avg_pass_yd > 100);
      if (qbs.length >= 2) {
        const probs = calculateSuperlativeProbs(qbs, 'avg_pass_yd', 'std_pass_yd');
        cards.push({
          id: 'most_pass_yd',
          title: 'Most Passing Yards',
          stat: 'pass_yd',
          statCategory: 'passing',
          players: qbs.map((qb, i) => ({
            name: qb.player_name,
            team: qb.team,
            avg: qb.avg_pass_yd,
            prob: probs[i]
          }))
        });
      }

      // Most Rushing Yards (RBs and rushing QBs)
      const rushers = players.filter(p =>
        (p.position === 'RB' && p.avg_rush_yd > 30) ||
        (p.position === 'QB' && p.avg_rush_yd > 20)
      );
      if (rushers.length >= 2) {
        const probs = calculateSuperlativeProbs(rushers, 'avg_rush_yd', 'std_rush_yd');
        cards.push({
          id: 'most_rush_yd',
          title: 'Most Rushing Yards',
          stat: 'rush_yd',
          statCategory: 'rushing',
          players: rushers.map((p, i) => ({
            name: p.player_name,
            team: p.team,
            avg: p.avg_rush_yd,
            prob: probs[i]
          }))
        });
      }

      // Most Receiving Yards (WRs and TEs)
      const receivers = players.filter(p =>
        (p.position === 'WR' || p.position === 'TE') && p.avg_rec_yd > 30
      ).sort((a, b) => b.avg_rec_yd - a.avg_rec_yd).slice(0, 6); // Top 6 receivers
      if (receivers.length >= 2) {
        const probs = calculateSuperlativeProbs(receivers, 'avg_rec_yd', 'std_rec_yd');
        cards.push({
          id: 'most_rec_yd',
          title: 'Most Receiving Yards',
          stat: 'rec_yd',
          statCategory: 'receiving',
          players: receivers.map((p, i) => ({
            name: p.player_name,
            team: p.team,
            avg: p.avg_rec_yd,
            prob: probs[i]
          }))
        });
      }

      // Most Receptions (WRs and TEs)
      const catchers = players.filter(p =>
        (p.position === 'WR' || p.position === 'TE') && p.avg_rec > 3
      ).sort((a, b) => b.avg_rec - a.avg_rec).slice(0, 6); // Top 6 catchers
      if (catchers.length >= 2) {
        const probs = calculateSuperlativeProbs(catchers, 'avg_rec', 'std_rec');
        cards.push({
          id: 'most_rec',
          title: 'Most Receptions',
          stat: 'rec',
          statCategory: 'receiving',
          players: catchers.map((p, i) => ({
            name: p.player_name,
            team: p.team,
            avg: p.avg_rec,
            prob: probs[i]
          }))
        });
      }

      return cards;
    }

    function calculateSuperlativeProbs(players, avgKey, stdKey) {
      // Calculate probability each player leads using Monte Carlo approximation
      // For simplicity, use pairwise comparison approach
      const n = players.length;
      const probs = new Array(n).fill(0);

      // For each player, calculate P(beats all others)
      for (let i = 0; i < n; i++) {
        let prob = 1;
        const pi = players[i];
        const avgI = pi[avgKey] || 0;
        const stdI = pi[stdKey] || (avgI * 0.3); // Default 30% CV if no std

        for (let j = 0; j < n; j++) {
          if (i === j) continue;
          const pj = players[j];
          const avgJ = pj[avgKey] || 0;
          const stdJ = pj[stdKey] || (avgJ * 0.3);

          // P(Xi > Xj) where Xi ~ N(avgI, stdI), Xj ~ N(avgJ, stdJ)
          // Xi - Xj ~ N(avgI - avgJ, sqrt(stdI^2 + stdJ^2))
          const diffMean = avgI - avgJ;
          const diffStd = Math.sqrt(stdI * stdI + stdJ * stdJ);
          const pWin = 1 - normalCDF(-diffMean / diffStd);

          prob *= pWin;
        }
        probs[i] = prob;
      }

      // Normalize probabilities to sum to 1
      const total = probs.reduce((a, b) => a + b, 0);
      if (total > 0) {
        for (let i = 0; i < n; i++) {
          probs[i] = probs[i] / total;
        }
      }

      return probs;
    }

    // Keep old function for suggested parlays (uses fair-line based props)
    function buildPlayerLegsForSuggestions(home, away) {
      const legs = [];
      propCards.forEach(card => {
        const line = roundToHalf(card.avg);
        const { overProb } = calculatePropOdds(card.avg, card.std, line);
        let adjustedProb = overProb;
        if (card.matchup) {
          if (card.matchup.quality === 'smash') adjustedProb = Math.min(0.78, adjustedProb + 0.08);
          if (card.matchup.quality === 'tough') adjustedProb = Math.max(0.22, adjustedProb - 0.08);
        }
        legs.push({
          id: `${card.stat}_over_${card.player}`,
          type: 'player',
          category: `${card.team} Players`,
          name: `${card.player} O ${line} ${card.statLabel.toLowerCase()}`,
          detail: `Avg: ${card.avg.toFixed(0)}`,
          odds: probToOdds(adjustedProb),
          prob: adjustedProb,
          team: card.team,
          player: card.player,
          stat: card.stat,
          position: card.position,
          matchup: card.matchup,
          trend: card.trend
        });
      });
      return legs;
    }

    function calculatePropOdds(avg, std, line) {
      // Use normal distribution CDF approximation
      const z = (line - avg) / (std || 1);
      const overProb = 1 - normalCDF(z);

      // Clamp probability
      const clampedOver = Math.max(0.2, Math.min(0.8, overProb));

      return {
        overProb: clampedOver,
        overOdds: probToOdds(clampedOver),
        underOdds: probToOdds(1 - clampedOver)
      };
    }

    function normalCDF(z) {
      // Approximation of standard normal CDF
      const a1 = 0.254829592;
      const a2 = -0.284496736;
      const a3 = 1.421413741;
      const a4 = -1.453152027;
      const a5 = 1.061405429;
      const p = 0.3275911;

      const sign = z < 0 ? -1 : 1;
      z = Math.abs(z) / Math.sqrt(2);

      const t = 1.0 / (1.0 + p * z);
      const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-z * z);

      return 0.5 * (1.0 + sign * y);
    }

    function probToOdds(prob) {
      if (prob >= 0.5) {
        return Math.round(-100 * prob / (1 - prob));
      } else {
        return Math.round(100 * (1 - prob) / prob);
      }
    }

    function roundToHalf(n) {
      return Math.round(n * 2) / 2;
    }

    function renderLegs() {
      const container = document.getElementById('legs-container');
      document.getElementById('legs-section').style.display = 'block';

      // Check if anything passes filters
      const showGame = filters.type === 'all' || filters.type === 'game';
      const showSuperlative = filters.type === 'all' || filters.type === 'superlative';
      const showProps = filters.type === 'all' || filters.type === 'props';

      if (availableLegs.length === 0 && propCards.length === 0 && superlativeCards.length === 0) {
        container.innerHTML = '<div class="no-data">No legs available for this matchup</div>';
        return;
      }

      let html = '';

      // Show H2H context if available (before game legs)
      if (h2hData && h2hData.games > 0 && showGame) {
        html += `
          <div class="h2h-context">
            <div class="h2h-context-title">H2H History (${h2hData.games} games)</div>
            <div class="h2h-context-stat">Avg Total: <span>${h2hData.avgTotal} pts</span> | Over 44 rate: <span>${h2hData.overRate}%</span></div>
          </div>
        `;
      }

      // Render game legs (ML, spread, total)
      if (showGame && availableLegs.length > 0) {
        const groups = {};
        availableLegs.forEach(leg => {
          if (!groups[leg.category]) groups[leg.category] = [];
          groups[leg.category].push(leg);
        });

        for (const [category, legs] of Object.entries(groups)) {
          html += `<div class="leg-group">
            <div class="leg-group-title">${category}</div>`;

          legs.forEach(leg => {
            const isSelected = selectedLegs.some(l => l.id === leg.id);
            html += `
              <div class="leg-item ${isSelected ? 'selected' : ''}" data-leg-id="${leg.id}">
                <div class="leg-checkbox">${isSelected ? '‚úì' : ''}</div>
                <div class="leg-info">
                  <div class="leg-name">${leg.name}</div>
                  <div class="leg-detail">${leg.detail}</div>
                </div>
                <div>
                  <div class="leg-odds">${formatOdds(leg.odds)}</div>
                  <div class="leg-prob">${(leg.prob * 100).toFixed(0)}%</div>
                </div>
              </div>
            `;
          });

          html += '</div>';
        }
      }

      // Render editable Spread card
      if (modelOdds) {
        const spreadInput = gameInputs.spread || {};
        const spreadLine = spreadInput.line;
        const homeSpreadOdds = spreadInput.homeOdds;
        const awaySpreadOdds = spreadInput.awayOdds;

        let homeSpreadProb = null, awaySpreadProb = null;
        let homeSpreadEdge = null, awaySpreadEdge = null;

        if (spreadLine !== undefined && spreadLine !== null && !isNaN(spreadLine)) {
          homeSpreadProb = calcSpreadProb(modelOdds.expectedMargin, spreadLine);
          awaySpreadProb = 1 - homeSpreadProb;

          if (homeSpreadOdds && !isNaN(homeSpreadOdds)) {
            homeSpreadEdge = calculateEdge(homeSpreadProb, parseInt(homeSpreadOdds));
          }
          if (awaySpreadOdds && !isNaN(awaySpreadOdds)) {
            awaySpreadEdge = calculateEdge(awaySpreadProb, parseInt(awaySpreadOdds));
          }
        }

        const isHomeSpreadSelected = selectedLegs.some(l => l.id === 'spread_home');
        const isAwaySpreadSelected = selectedLegs.some(l => l.id === 'spread_away');

        html += `
          <div class="leg-group">
            <div class="leg-group-title">Spread</div>
            <div class="prop-card" data-game-type="spread">
              <div class="prop-card-header">
                <div>
                  <div class="prop-player-name">${modelOdds.home} vs ${modelOdds.away}</div>
                  <div class="prop-stat-type">Model expected margin: ${modelOdds.home} ${modelOdds.expectedMargin >= 0 ? '-' : '+'}${Math.abs(modelOdds.expectedMargin).toFixed(1)}</div>
                </div>
              </div>
              <div class="prop-inputs">
                <div class="prop-input-group">
                  <label>Line (home):</label>
                  <input type="text" class="spread-line-input line-input"
                         value="${spreadLine !== undefined ? spreadLine : ''}" placeholder="${(-modelOdds.expectedMargin).toFixed(1)}">
                </div>
                <div class="prop-odds-row">
                  <div class="prop-input-group">
                    <label>${modelOdds.home}:</label>
                    <input type="text" class="spread-home-odds-input"
                           value="${homeSpreadOdds || ''}" placeholder="-110">
                  </div>
                  <div class="prop-input-group">
                    <label>${modelOdds.away}:</label>
                    <input type="text" class="spread-away-odds-input"
                           value="${awaySpreadOdds || ''}" placeholder="-110">
                  </div>
                </div>
              </div>
              ${spreadLine !== undefined && spreadLine !== null ? `
                <div class="prop-stats-row" style="margin-top: 0.5rem; margin-bottom: 0.5rem;">
                  Fair odds at this line: <span>${formatOdds(probToOdds(homeSpreadProb))} / ${formatOdds(probToOdds(awaySpreadProb))}</span>
                </div>
                <div class="prop-results">
                  <div class="prop-bet-option ${isHomeSpreadSelected ? 'selected' : ''} ${homeSpreadEdge !== null && homeSpreadEdge > 3 ? 'has-edge' : ''}"
                       data-game-type="spread" data-side="home">
                    <div class="prop-bet-label">${modelOdds.home} ${spreadLine >= 0 ? '+' : ''}${spreadLine}</div>
                    <div class="prop-bet-prob">${(homeSpreadProb * 100).toFixed(0)}% model</div>
                    ${homeSpreadEdge !== null ? `<div class="prop-bet-edge ${homeSpreadEdge >= 0 ? 'positive' : 'negative'}">${homeSpreadEdge >= 0 ? '+' : ''}${homeSpreadEdge.toFixed(1)}% edge</div>` : '<div class="prop-bet-edge" style="color: var(--text-muted)">enter odds</div>'}
                  </div>
                  <div class="prop-bet-option ${isAwaySpreadSelected ? 'selected' : ''} ${awaySpreadEdge !== null && awaySpreadEdge > 3 ? 'has-edge' : ''}"
                       data-game-type="spread" data-side="away">
                    <div class="prop-bet-label">${modelOdds.away} ${-spreadLine >= 0 ? '+' : ''}${-spreadLine}</div>
                    <div class="prop-bet-prob">${(awaySpreadProb * 100).toFixed(0)}% model</div>
                    ${awaySpreadEdge !== null ? `<div class="prop-bet-edge ${awaySpreadEdge >= 0 ? 'positive' : 'negative'}">${awaySpreadEdge >= 0 ? '+' : ''}${awaySpreadEdge.toFixed(1)}% edge</div>` : '<div class="prop-bet-edge" style="color: var(--text-muted)">enter odds</div>'}
                  </div>
                </div>
              ` : '<div class="prop-no-line">Enter sportsbook spread to evaluate</div>'}
            </div>
          </div>
        `;

        // Render editable Total card
        const totalInput = gameInputs.total || {};
        const totalLine = totalInput.line;
        const overOdds = totalInput.overOdds;
        const underOdds = totalInput.underOdds;

        let overProb = null, underProb = null;
        let overEdge = null, underEdge = null;

        if (totalLine !== undefined && totalLine !== null && !isNaN(totalLine)) {
          overProb = calcTotalProb(modelOdds.expectedTotal, totalLine);
          underProb = 1 - overProb;

          if (overOdds && !isNaN(overOdds)) {
            overEdge = calculateEdge(overProb, parseInt(overOdds));
          }
          if (underOdds && !isNaN(underOdds)) {
            underEdge = calculateEdge(underProb, parseInt(underOdds));
          }
        }

        const isOverSelected = selectedLegs.some(l => l.id === 'total_over');
        const isUnderSelected = selectedLegs.some(l => l.id === 'total_under');

        html += `
          <div class="leg-group">
            <div class="leg-group-title">Total Points</div>
            <div class="prop-card" data-game-type="total">
              <div class="prop-card-header">
                <div>
                  <div class="prop-player-name">Game Total</div>
                  <div class="prop-stat-type">Model expected: ${modelOdds.expectedTotal.toFixed(1)} points</div>
                </div>
              </div>
              <div class="prop-inputs">
                <div class="prop-input-group">
                  <label>Line:</label>
                  <input type="text" class="total-line-input line-input"
                         value="${totalLine !== undefined ? totalLine : ''}" placeholder="${modelOdds.expectedTotal.toFixed(1)}">
                </div>
                <div class="prop-odds-row">
                  <div class="prop-input-group">
                    <label>Over:</label>
                    <input type="text" class="total-over-odds-input"
                           value="${overOdds || ''}" placeholder="-110">
                  </div>
                  <div class="prop-input-group">
                    <label>Under:</label>
                    <input type="text" class="total-under-odds-input"
                           value="${underOdds || ''}" placeholder="-110">
                  </div>
                </div>
              </div>
              ${totalLine !== undefined && totalLine !== null ? `
                <div class="prop-stats-row" style="margin-top: 0.5rem; margin-bottom: 0.5rem;">
                  Fair odds at this line: <span>O ${formatOdds(probToOdds(overProb))} / U ${formatOdds(probToOdds(underProb))}</span>
                </div>
                <div class="prop-results">
                  <div class="prop-bet-option ${isOverSelected ? 'selected' : ''} ${overEdge !== null && overEdge > 3 ? 'has-edge' : ''}"
                       data-game-type="total" data-side="over">
                    <div class="prop-bet-label">Over ${totalLine}</div>
                    <div class="prop-bet-prob">${(overProb * 100).toFixed(0)}% model</div>
                    ${overEdge !== null ? `<div class="prop-bet-edge ${overEdge >= 0 ? 'positive' : 'negative'}">${overEdge >= 0 ? '+' : ''}${overEdge.toFixed(1)}% edge</div>` : '<div class="prop-bet-edge" style="color: var(--text-muted)">enter odds</div>'}
                  </div>
                  <div class="prop-bet-option ${isUnderSelected ? 'selected' : ''} ${underEdge !== null && underEdge > 3 ? 'has-edge' : ''}"
                       data-game-type="total" data-side="under">
                    <div class="prop-bet-label">Under ${totalLine}</div>
                    <div class="prop-bet-prob">${(underProb * 100).toFixed(0)}% model</div>
                    ${underEdge !== null ? `<div class="prop-bet-edge ${underEdge >= 0 ? 'positive' : 'negative'}">${underEdge >= 0 ? '+' : ''}${underEdge.toFixed(1)}% edge</div>` : '<div class="prop-bet-edge" style="color: var(--text-muted)">enter odds</div>'}
                  </div>
                </div>
              ` : '<div class="prop-no-line">Enter sportsbook total to evaluate</div>'}
            </div>
          </div>
        `;
      }

      // Render superlative props (Most Passing Yards, etc.)
      if (showSuperlative && superlativeCards.length > 0) {
        // Filter by stat category
        const filteredSuperlatives = superlativeCards.filter(card => {
          if (filters.stat === 'all') return true;
          return card.statCategory === filters.stat;
        });

        if (filteredSuperlatives.length > 0) {
          html += `<div class="leg-group">
            <div class="leg-group-title">Superlative Props</div>`;

          filteredSuperlatives.forEach(card => {
            const inputs = superlativeInputs[card.id] || {};

            html += `
              <div class="superlative-card" data-superlative-id="${card.id}">
                <div class="superlative-title">${card.title}</div>
                <div class="superlative-options">
            `;

            card.players.forEach(player => {
              const playerId = `${card.id}_${player.name.replace(/[^a-zA-Z0-9]/g, '_')}`;
              const isSelected = selectedLegs.some(l => l.id === playerId);
              const playerOdds = inputs[player.name];
              const edge = playerOdds ? calculateEdge(player.prob, parseInt(playerOdds)) : null;

              html += `
                <div class="superlative-option ${isSelected ? 'selected' : ''} ${edge !== null && edge > 3 ? 'has-edge' : ''}"
                     data-superlative-id="${card.id}" data-player="${player.name}">
                  <div class="superlative-player">${player.name}</div>
                  <div class="superlative-team">${player.team} | Avg: ${player.avg.toFixed(0)}</div>
                  <div class="superlative-prob">${(player.prob * 100).toFixed(0)}% model</div>
                  <input type="text" class="superlative-odds-input" data-superlative-id="${card.id}" data-player="${player.name}"
                         value="${playerOdds || ''}" placeholder="${formatOdds(probToOdds(player.prob))}"
                         onclick="event.stopPropagation()">
                  ${edge !== null ? `<div class="superlative-edge ${edge >= 0 ? 'positive' : 'negative'}">${edge >= 0 ? '+' : ''}${edge.toFixed(1)}% edge</div>` : ''}
                </div>
              `;
            });

            html += `
                </div>
              </div>
            `;
          });

          html += '</div>';
        }
      }

      // Render prop cards grouped by team
      if (showProps && propCards.length > 0) {
        const byTeam = {};
        propCards.forEach(card => {
          // Apply team filter
          if (filters.team !== 'all' && card.team !== filters.team) return;
          // Apply stat filter
          if (filters.stat !== 'all') {
            const statCategory = card.stat === 'pass_yd' ? 'passing' :
                                card.stat.includes('rush') ? 'rushing' : 'receiving';
            if (statCategory !== filters.stat) return;
          }
          if (!byTeam[card.team]) byTeam[card.team] = [];
          byTeam[card.team].push(card);
        });

        for (const [team, cards] of Object.entries(byTeam)) {
          if (cards.length === 0) continue;
          html += `<div class="leg-group">
            <div class="leg-group-title">${team} Player Props</div>`;

          cards.forEach(card => {
            const input = propInputs[card.id] || {};
            const line = input.line;
            const overOdds = input.overOdds;
            const underOdds = input.underOdds;

            // Build badges
            let badges = '';
            if (card.matchup) {
              const label = card.matchup.quality === 'smash' ? 'Smash'
                          : card.matchup.quality === 'tough' ? 'Tough' : '';
              if (label) {
                badges += `<span class="matchup-badge ${card.matchup.quality}">${label}</span>`;
              }
            }
            if (card.trend) {
              const icon = card.trend.trend === 'hot' ? 'üî•' : '‚ùÑÔ∏è';
              badges += `<span class="trend-badge ${card.trend.trend}">${icon} ${card.trend.trend.toUpperCase()}</span>`;
            }

            // Calculate probabilities if line is set
            let overProb = null, underProb = null, overEdge = null, underEdge = null;
            if (line && !isNaN(line)) {
              const result = calculatePropOdds(card.avg, card.std, parseFloat(line));
              overProb = result.overProb;
              underProb = 1 - overProb;

              // Apply matchup adjustment
              if (card.matchup) {
                if (card.matchup.quality === 'smash') {
                  overProb = Math.min(0.85, overProb + 0.08);
                  underProb = 1 - overProb;
                } else if (card.matchup.quality === 'tough') {
                  overProb = Math.max(0.15, overProb - 0.08);
                  underProb = 1 - overProb;
                }
              }

              // Calculate edge for each side with its own odds
              if (overOdds && !isNaN(overOdds)) {
                overEdge = calculateEdge(overProb, parseInt(overOdds));
              }
              if (underOdds && !isNaN(underOdds)) {
                underEdge = calculateEdge(underProb, parseInt(underOdds));
              }
            }

            const isOverSelected = selectedLegs.some(l => l.id === `${card.id}_over`);
            const isUnderSelected = selectedLegs.some(l => l.id === `${card.id}_under`);

            html += `
              <div class="prop-card" data-prop-id="${card.id}">
                <div class="prop-card-header">
                  <div>
                    <div class="prop-player-name">${card.player}</div>
                    <div class="prop-stat-type">${card.statLabel}</div>
                  </div>
                  <div class="prop-badges">${badges}</div>
                </div>
                <div class="prop-stats-row">
                  Avg: <span>${card.avg.toFixed(1)}</span> | œÉ: <span>${card.std.toFixed(1)}</span>
                </div>
                <div class="prop-inputs">
                  <div class="prop-input-group">
                    <label>Line:</label>
                    <input type="text" class="prop-line-input line-input" data-prop-id="${card.id}"
                           value="${line || ''}" placeholder="${card.avg.toFixed(1)}">
                  </div>
                  <div class="prop-odds-row">
                    <div class="prop-input-group">
                      <label>O:</label>
                      <input type="text" class="prop-over-odds-input" data-prop-id="${card.id}"
                             value="${overOdds || ''}" placeholder="-110">
                    </div>
                    <div class="prop-input-group">
                      <label>U:</label>
                      <input type="text" class="prop-under-odds-input" data-prop-id="${card.id}"
                             value="${underOdds || ''}" placeholder="-110">
                    </div>
                  </div>
                </div>
                ${line ? `
                  <div class="prop-stats-row" style="margin-top: 0.25rem; margin-bottom: 0.5rem;">
                    Fair odds: <span>O ${formatOdds(probToOdds(overProb))} / U ${formatOdds(probToOdds(underProb))}</span>
                  </div>
                  <div class="prop-results">
                    <div class="prop-bet-option ${isOverSelected ? 'selected' : ''} ${overEdge !== null && overEdge > 3 ? 'has-edge' : ''}"
                         data-prop-id="${card.id}" data-side="over">
                      <div class="prop-bet-label">Over ${line}</div>
                      <div class="prop-bet-prob">${(overProb * 100).toFixed(0)}% model</div>
                      ${overEdge !== null ? `<div class="prop-bet-edge ${overEdge >= 0 ? 'positive' : 'negative'}">${overEdge >= 0 ? '+' : ''}${overEdge.toFixed(1)}% edge</div>` : '<div class="prop-bet-edge" style="color: var(--text-muted)">enter odds</div>'}
                    </div>
                    <div class="prop-bet-option ${isUnderSelected ? 'selected' : ''} ${underEdge !== null && underEdge > 3 ? 'has-edge' : ''}"
                         data-prop-id="${card.id}" data-side="under">
                      <div class="prop-bet-label">Under ${line}</div>
                      <div class="prop-bet-prob">${(underProb * 100).toFixed(0)}% model</div>
                      ${underEdge !== null ? `<div class="prop-bet-edge ${underEdge >= 0 ? 'positive' : 'negative'}">${underEdge >= 0 ? '+' : ''}${underEdge.toFixed(1)}% edge</div>` : '<div class="prop-bet-edge" style="color: var(--text-muted)">enter odds</div>'}
                    </div>
                  </div>
                ` : '<div class="prop-no-line">Enter sportsbook line to evaluate</div>'}
              </div>
            `;
          });

          html += '</div>';
        }
      }

      container.innerHTML = html;

      // Add click handlers for game legs
      container.querySelectorAll('.leg-item').forEach(el => {
        el.addEventListener('click', () => {
          const legId = el.dataset.legId;
          toggleLeg(legId);
        });
      });

      // Add input handlers for prop cards
      container.querySelectorAll('.prop-line-input').forEach(input => {
        input.addEventListener('change', (e) => {
          const propId = e.target.dataset.propId;
          const value = e.target.value.trim();
          if (!propInputs[propId]) propInputs[propId] = {};
          propInputs[propId].line = value ? parseFloat(value) : null;
          renderLegs();
        });
      });

      container.querySelectorAll('.prop-over-odds-input').forEach(input => {
        input.addEventListener('change', (e) => {
          const propId = e.target.dataset.propId;
          const value = e.target.value.trim();
          if (!propInputs[propId]) propInputs[propId] = {};
          propInputs[propId].overOdds = value ? parseInt(value) : null;
          renderLegs();
        });
      });

      container.querySelectorAll('.prop-under-odds-input').forEach(input => {
        input.addEventListener('change', (e) => {
          const propId = e.target.dataset.propId;
          const value = e.target.value.trim();
          if (!propInputs[propId]) propInputs[propId] = {};
          propInputs[propId].underOdds = value ? parseInt(value) : null;
          renderLegs();
        });
      });

      // Add click handlers for prop bet options
      container.querySelectorAll('.prop-bet-option').forEach(el => {
        el.addEventListener('click', () => {
          const gameType = el.dataset.gameType;
          const side = el.dataset.side;

          if (gameType === 'spread' || gameType === 'total') {
            toggleGameLeg(gameType, side);
          } else {
            const propId = el.dataset.propId;
            togglePropLeg(propId, side);
          }
        });
      });

      // Add input handlers for spread card
      container.querySelectorAll('.spread-line-input').forEach(input => {
        input.addEventListener('change', (e) => {
          const value = e.target.value.trim();
          if (!gameInputs.spread) gameInputs.spread = {};
          gameInputs.spread.line = value !== '' ? parseFloat(value) : null;
          renderLegs();
        });
      });

      container.querySelectorAll('.spread-home-odds-input').forEach(input => {
        input.addEventListener('change', (e) => {
          const value = e.target.value.trim();
          if (!gameInputs.spread) gameInputs.spread = {};
          gameInputs.spread.homeOdds = value ? parseInt(value) : null;
          renderLegs();
        });
      });

      container.querySelectorAll('.spread-away-odds-input').forEach(input => {
        input.addEventListener('change', (e) => {
          const value = e.target.value.trim();
          if (!gameInputs.spread) gameInputs.spread = {};
          gameInputs.spread.awayOdds = value ? parseInt(value) : null;
          renderLegs();
        });
      });

      // Add input handlers for total card
      container.querySelectorAll('.total-line-input').forEach(input => {
        input.addEventListener('change', (e) => {
          const value = e.target.value.trim();
          if (!gameInputs.total) gameInputs.total = {};
          gameInputs.total.line = value !== '' ? parseFloat(value) : null;
          renderLegs();
        });
      });

      container.querySelectorAll('.total-over-odds-input').forEach(input => {
        input.addEventListener('change', (e) => {
          const value = e.target.value.trim();
          if (!gameInputs.total) gameInputs.total = {};
          gameInputs.total.overOdds = value ? parseInt(value) : null;
          renderLegs();
        });
      });

      container.querySelectorAll('.total-under-odds-input').forEach(input => {
        input.addEventListener('change', (e) => {
          const value = e.target.value.trim();
          if (!gameInputs.total) gameInputs.total = {};
          gameInputs.total.underOdds = value ? parseInt(value) : null;
          renderLegs();
        });
      });

      // Add superlative odds input handlers
      container.querySelectorAll('.superlative-odds-input').forEach(input => {
        input.addEventListener('change', (e) => {
          const supId = e.target.dataset.superlativeId;
          const player = e.target.dataset.player;
          const value = e.target.value.trim();
          if (!superlativeInputs[supId]) superlativeInputs[supId] = {};
          superlativeInputs[supId][player] = value ? parseInt(value) : null;
          renderLegs();
        });
      });

      // Add superlative option click handlers
      container.querySelectorAll('.superlative-option').forEach(el => {
        el.addEventListener('click', () => {
          const supId = el.dataset.superlativeId;
          const playerName = el.dataset.player;
          toggleSuperlativeLeg(supId, playerName);
        });
      });
    }

    function togglePropLeg(propId, side) {
      const card = propCards.find(c => c.id === propId);
      const input = propInputs[propId];
      if (!card || !input || !input.line) return;

      const legId = `${propId}_${side}`;
      const oppositeId = `${propId}_${side === 'over' ? 'under' : 'over'}`;

      // Remove opposite side if selected
      selectedLegs = selectedLegs.filter(l => l.id !== oppositeId);

      const idx = selectedLegs.findIndex(l => l.id === legId);
      if (idx >= 0) {
        selectedLegs.splice(idx, 1);
      } else {
        const { overProb } = calculatePropOdds(card.avg, card.std, input.line);
        let prob = side === 'over' ? overProb : 1 - overProb;

        // Apply matchup adjustment
        if (card.matchup) {
          if (card.matchup.quality === 'smash') {
            prob = side === 'over' ? Math.min(0.85, prob + 0.08) : Math.max(0.15, prob - 0.08);
          } else if (card.matchup.quality === 'tough') {
            prob = side === 'over' ? Math.max(0.15, prob - 0.08) : Math.min(0.85, prob + 0.08);
          }
        }

        // Get the correct odds for this side
        const sideOdds = side === 'over' ? input.overOdds : input.underOdds;

        selectedLegs.push({
          id: legId,
          type: 'player',
          category: `${card.team} Players`,
          name: `${card.player} ${side === 'over' ? 'O' : 'U'} ${input.line} ${card.statLabel.toLowerCase()}`,
          detail: `Avg: ${card.avg.toFixed(0)}`,
          odds: sideOdds ? sideOdds : probToOdds(prob),
          prob: prob,
          team: card.team,
          player: card.player,
          stat: card.stat,
          position: card.position,
          matchup: card.matchup,
          trend: card.trend,
          marketLine: input.line,
          marketOdds: sideOdds
        });
      }

      renderLegs();
      renderSlip();
    }

    function toggleGameLeg(gameType, side) {
      if (!modelOdds) return;

      if (gameType === 'spread') {
        const input = gameInputs.spread;
        if (!input || input.line === null || input.line === undefined) return;

        const homeId = 'spread_home';
        const awayId = 'spread_away';
        const legId = side === 'home' ? homeId : awayId;
        const oppositeId = side === 'home' ? awayId : homeId;

        // Remove opposite side if selected
        selectedLegs = selectedLegs.filter(l => l.id !== oppositeId);

        const idx = selectedLegs.findIndex(l => l.id === legId);
        if (idx >= 0) {
          selectedLegs.splice(idx, 1);
        } else {
          const homeProb = calcSpreadProb(modelOdds.expectedMargin, input.line);
          const prob = side === 'home' ? homeProb : 1 - homeProb;
          const sideOdds = side === 'home' ? input.homeOdds : input.awayOdds;
          const spreadVal = side === 'home' ? input.line : -input.line;
          const team = side === 'home' ? modelOdds.home : modelOdds.away;

          selectedLegs.push({
            id: legId,
            type: 'game',
            category: 'Spread',
            name: `${team} ${spreadVal >= 0 ? '+' : ''}${spreadVal}`,
            detail: `Model: ${(prob * 100).toFixed(0)}%`,
            odds: sideOdds ? sideOdds : probToOdds(prob),
            prob: prob,
            team: team,
            marketLine: input.line,
            marketOdds: sideOdds
          });
        }
      } else if (gameType === 'total') {
        const input = gameInputs.total;
        if (!input || input.line === null || input.line === undefined) return;

        const overId = 'total_over';
        const underId = 'total_under';
        const legId = side === 'over' ? overId : underId;
        const oppositeId = side === 'over' ? underId : overId;

        // Remove opposite side if selected
        selectedLegs = selectedLegs.filter(l => l.id !== oppositeId);

        const idx = selectedLegs.findIndex(l => l.id === legId);
        if (idx >= 0) {
          selectedLegs.splice(idx, 1);
        } else {
          const overProb = calcTotalProb(modelOdds.expectedTotal, input.line);
          const prob = side === 'over' ? overProb : 1 - overProb;
          const sideOdds = side === 'over' ? input.overOdds : input.underOdds;

          selectedLegs.push({
            id: legId,
            type: 'game',
            category: 'Total',
            name: `${side === 'over' ? 'Over' : 'Under'} ${input.line}`,
            detail: `Model: ${(prob * 100).toFixed(0)}%`,
            odds: sideOdds ? sideOdds : probToOdds(prob),
            prob: prob,
            marketLine: input.line,
            marketOdds: sideOdds
          });
        }
      }

      renderLegs();
      renderSlip();
    }

    function toggleSuperlativeLeg(supId, playerName) {
      const card = superlativeCards.find(c => c.id === supId);
      if (!card) return;

      const player = card.players.find(p => p.name === playerName);
      if (!player) return;

      const legId = `${supId}_${playerName.replace(/[^a-zA-Z0-9]/g, '_')}`;

      // Remove all other players from this superlative (only one can win)
      card.players.forEach(p => {
        const otherId = `${supId}_${p.name.replace(/[^a-zA-Z0-9]/g, '_')}`;
        if (otherId !== legId) {
          selectedLegs = selectedLegs.filter(l => l.id !== otherId);
        }
      });

      const idx = selectedLegs.findIndex(l => l.id === legId);
      if (idx >= 0) {
        selectedLegs.splice(idx, 1);
      } else {
        const inputs = superlativeInputs[supId] || {};
        const playerOdds = inputs[playerName];

        selectedLegs.push({
          id: legId,
          type: 'superlative',
          category: 'Superlatives',
          name: `${playerName} - ${card.title}`,
          detail: `Model: ${(player.prob * 100).toFixed(0)}%`,
          odds: playerOdds ? playerOdds : probToOdds(player.prob),
          prob: player.prob,
          team: player.team,
          player: playerName,
          superlativeId: supId
        });
      }

      renderLegs();
      renderSlip();
    }

    function toggleLeg(legId) {
      const leg = availableLegs.find(l => l.id === legId);
      if (!leg) return;

      const idx = selectedLegs.findIndex(l => l.id === legId);
      if (idx >= 0) {
        selectedLegs.splice(idx, 1);
      } else {
        // Check for conflicting legs
        const conflicting = selectedLegs.findIndex(l => isConflicting(l, leg));
        if (conflicting >= 0) {
          selectedLegs.splice(conflicting, 1);
        }
        selectedLegs.push(leg);
      }

      renderLegs();
      renderSlip();
    }

    function isConflicting(leg1, leg2) {
      // Same game leg type (can't have both ML, both spreads, etc.)
      if (leg1.type === 'game' && leg2.type === 'game') {
        if (leg1.category === leg2.category) return true;
      }

      // Same player, same stat (over vs under)
      if (leg1.type === 'player' && leg2.type === 'player') {
        if (leg1.player === leg2.player && leg1.stat === leg2.stat) return true;
      }

      return false;
    }

    function renderSlip() {
      const legsContainer = document.getElementById('slip-legs');
      const summary = document.getElementById('slip-summary');
      const warning = document.getElementById('correlation-warning');

      if (selectedLegs.length === 0) {
        legsContainer.innerHTML = '<div class="slip-empty">Add 2+ legs to build a parlay</div>';
        summary.style.display = 'none';
        warning.style.display = 'none';
        return;
      }

      let html = '';
      selectedLegs.forEach(leg => {
        const mktOdds = marketOdds[leg.id];
        const edge = mktOdds ? calculateEdge(leg.prob, mktOdds) : null;
        const edgeHtml = edge !== null
          ? `<span class="edge-indicator ${edge >= 0 ? 'positive' : 'negative'}">${edge >= 0 ? '+' : ''}${edge.toFixed(1)}%</span>`
          : '';

        html += `
          <div class="slip-leg">
            <div style="flex: 1; min-width: 0;">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <span class="slip-leg-name">${leg.name}</span>
                <span class="slip-leg-odds">${formatOdds(leg.odds)}</span>
              </div>
              <div class="slip-leg-market">
                <label>Market:</label>
                <input type="text" class="market-odds-input" data-leg-id="${leg.id}"
                       value="${mktOdds || ''}" placeholder="+/-odds">
                ${edgeHtml}
              </div>
            </div>
            <button class="slip-leg-remove" data-leg-id="${leg.id}">&times;</button>
          </div>
        `;
      });
      legsContainer.innerHTML = html;

      // Add remove handlers
      legsContainer.querySelectorAll('.slip-leg-remove').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const legId = btn.dataset.legId;
          selectedLegs = selectedLegs.filter(l => l.id !== legId);
          delete marketOdds[legId];
          renderLegs();
          renderSlip();
        });
      });

      // Add market odds input handlers
      legsContainer.querySelectorAll('.market-odds-input').forEach(input => {
        input.addEventListener('change', (e) => {
          const legId = e.target.dataset.legId;
          const value = e.target.value.trim();
          if (value && !isNaN(parseInt(value))) {
            marketOdds[legId] = parseInt(value);
          } else {
            delete marketOdds[legId];
          }
          renderSlip();
        });
      });

      // Calculate parlay
      const { combinedProb, combinedOdds, payout } = calculateParlay();

      document.getElementById('leg-count').textContent = selectedLegs.length;
      document.getElementById('combined-odds').textContent = formatOdds(combinedOdds);
      document.getElementById('win-prob').textContent = `${(combinedProb * 100).toFixed(1)}%`;
      document.getElementById('win-prob').className = `summary-value ${combinedProb < 0.1 ? 'warning' : ''}`;
      document.getElementById('prob-fill').style.width = `${combinedProb * 100}%`;

      const wager = parseFloat(document.getElementById('wager-amount').value) || 10;
      document.getElementById('potential-win').textContent = `$${payout.toFixed(2)}`;

      summary.style.display = selectedLegs.length >= 2 ? 'block' : 'none';

      // Check for correlations and show details
      const { hasCorrelation, correlations } = checkCorrelations();
      if (hasCorrelation && correlations.length > 0) {
        let corrHtml = '<div class="correlation-warning">Correlated legs detected:</div>';
        corrHtml += '<div class="correlation-details">';
        correlations.forEach(c => {
          const effectClass = c.effect === 'boost' ? 'correlation-boost' : 'correlation-conflict';
          corrHtml += `
            <div class="correlation-row">
              <span>${c.description}</span>
              <span class="${effectClass}">${c.adjustment}</span>
            </div>
          `;
        });
        corrHtml += '</div>';
        warning.innerHTML = corrHtml;
        warning.style.display = 'block';
      } else {
        warning.style.display = 'none';
      }
    }

    function calculateParlay() {
      if (selectedLegs.length === 0) {
        return { combinedProb: 0, combinedOdds: 0, payout: 0 };
      }

      // Combined probability (assuming independence)
      let combinedProb = 1;
      selectedLegs.forEach(leg => {
        combinedProb *= leg.prob;
      });

      // Combined decimal odds
      let decimalMultiplier = 1;
      selectedLegs.forEach(leg => {
        const decimal = leg.odds > 0 ? (leg.odds / 100) + 1 : (100 / Math.abs(leg.odds)) + 1;
        decimalMultiplier *= decimal;
      });

      // Convert back to American
      const combinedOdds = decimalMultiplier >= 2
        ? Math.round((decimalMultiplier - 1) * 100)
        : Math.round(-100 / (decimalMultiplier - 1));

      const wager = parseFloat(document.getElementById('wager-amount').value) || 10;
      const payout = wager * (decimalMultiplier - 1);

      return { combinedProb, combinedOdds, payout };
    }

    function checkCorrelations() {
      // Returns object with hasCorrelation flag and detailed analysis
      const correlations = [];

      // Multiple legs from same player
      const playerLegs = selectedLegs.filter(l => l.player);
      const playerCounts = {};
      playerLegs.forEach(l => {
        playerCounts[l.player] = (playerCounts[l.player] || 0) + 1;
      });
      Object.entries(playerCounts).forEach(([player, count]) => {
        if (count > 1) {
          const legs = playerLegs.filter(l => l.player === player);
          correlations.push({
            type: 'same-player',
            description: `${player}: ${legs.map(l => l.stat).join(' + ')}`,
            effect: 'boost',
            adjustment: '+5-10%'
          });
        }
      });

      // Game total + player yards (positive correlation)
      const hasOver = selectedLegs.some(l => l.id === 'over');
      const hasUnder = selectedLegs.some(l => l.id === 'under');
      const yardLegs = selectedLegs.filter(l => l.stat && l.stat.includes('yd') && l.id.includes('over'));
      const underYardLegs = selectedLegs.filter(l => l.stat && l.stat.includes('yd') && l.id.includes('under'));

      if (hasOver && yardLegs.length > 0) {
        correlations.push({
          type: 'total-yards',
          description: `Over + ${yardLegs.length} yardage overs`,
          effect: 'boost',
          adjustment: '+8-12%'
        });
      }
      if (hasUnder && underYardLegs.length > 0) {
        correlations.push({
          type: 'total-yards',
          description: `Under + ${underYardLegs.length} yardage unders`,
          effect: 'boost',
          adjustment: '+8-12%'
        });
      }
      if (hasOver && underYardLegs.length > 0) {
        correlations.push({
          type: 'conflict',
          description: `Over + yardage unders conflict`,
          effect: 'conflict',
          adjustment: '-10-15%'
        });
      }
      if (hasUnder && yardLegs.length > 0) {
        correlations.push({
          type: 'conflict',
          description: `Under + yardage overs conflict`,
          effect: 'conflict',
          adjustment: '-10-15%'
        });
      }

      // Team win + team player props (positive correlation)
      const mlLegs = selectedLegs.filter(l => l.id && l.id.startsWith('ml_'));
      mlLegs.forEach(ml => {
        const teamPlayerOvers = selectedLegs.filter(l =>
          l.type === 'player' && l.team === ml.team && l.id && l.id.includes('over')
        );
        if (teamPlayerOvers.length > 0) {
          correlations.push({
            type: 'team-player',
            description: `${ml.team} ML + ${teamPlayerOvers.length} player overs`,
            effect: 'boost',
            adjustment: '+5-8%'
          });
        }
      });

      return {
        hasCorrelation: correlations.length > 0,
        correlations: correlations
      };
    }

    function calculateEdge(modelProb, marketOdds) {
      // Convert market odds to implied probability
      let impliedProb;
      if (marketOdds > 0) {
        impliedProb = 100 / (marketOdds + 100);
      } else {
        impliedProb = Math.abs(marketOdds) / (Math.abs(marketOdds) + 100);
      }

      // Edge = model probability - implied probability
      return (modelProb - impliedProb) * 100;
    }

    function formatOdds(odds) {
      if (odds > 0) return '+' + odds;
      return String(odds);
    }

    function generateSuggestedParlays() {
      const container = document.getElementById('suggested-container');
      document.getElementById('suggested-section').style.display = 'block';

      // Combine game legs with player prop legs for suggestions
      const playerLegsForSuggestions = buildPlayerLegsForSuggestions(currentMatchup.home, currentMatchup.away);
      const allLegs = [...availableLegs, ...playerLegsForSuggestions];

      if (allLegs.length < 3) {
        container.innerHTML = '<div class="no-data">Not enough legs available</div>';
        return;
      }

      const suggestions = [];

      // Find high-probability legs (55-70%)
      const highProbLegs = allLegs.filter(l => l.prob >= 0.52 && l.prob <= 0.72);

      // Strategy 1: "Safe" parlay - 3 highest probability legs
      const safeLegs = [...allLegs]
        .filter(l => l.prob >= 0.5)
        .sort((a, b) => b.prob - a.prob)
        .slice(0, 4);

      if (safeLegs.length >= 3) {
        const safePick = findBestCombination(safeLegs, 3);
        if (safePick) {
          suggestions.push({
            name: 'Conservative',
            legs: safePick.legs,
            prob: safePick.prob,
            odds: safePick.odds
          });
        }
      }

      // Strategy 2: "Balanced" - mix of game and player props
      const gameLegs = allLegs.filter(l => l.type === 'game' && l.prob >= 0.45);
      const playerLegs = allLegs.filter(l => l.type === 'player' && l.prob >= 0.5);

      if (gameLegs.length >= 1 && playerLegs.length >= 2) {
        const balancedLegs = [
          ...gameLegs.sort((a, b) => b.prob - a.prob).slice(0, 1),
          ...playerLegs.sort((a, b) => b.prob - a.prob).slice(0, 2)
        ];
        const balanced = calculateParlayForLegs(balancedLegs);
        suggestions.push({
          name: 'Balanced Mix',
          legs: balancedLegs,
          prob: balanced.prob,
          odds: balanced.odds
        });
      }

      // Strategy 3: "Value" - best expected value
      const evLegs = allLegs
        .map(l => ({
          ...l,
          ev: l.prob * (l.odds > 0 ? l.odds / 100 : 100 / Math.abs(l.odds))
        }))
        .filter(l => l.ev > 0.4)
        .sort((a, b) => b.ev - a.ev)
        .slice(0, 4);

      if (evLegs.length >= 3) {
        const valuePick = findBestCombination(evLegs, 3);
        if (valuePick) {
          suggestions.push({
            name: 'Value Play',
            legs: valuePick.legs,
            prob: valuePick.prob,
            odds: valuePick.odds
          });
        }
      }

      // Strategy 4: "Long Shot" - higher payout
      const longLegs = allLegs
        .filter(l => l.prob >= 0.35 && l.prob <= 0.55 && l.odds > 0)
        .sort((a, b) => b.odds - a.odds)
        .slice(0, 3);

      if (longLegs.length >= 3) {
        const longShot = calculateParlayForLegs(longLegs);
        suggestions.push({
          name: 'Long Shot',
          legs: longLegs,
          prob: longShot.prob,
          odds: longShot.odds
        });
      }

      // Render suggestions
      if (suggestions.length === 0) {
        container.innerHTML = '<div class="no-data">Could not generate suggestions</div>';
        return;
      }

      container.innerHTML = suggestions.map((s, i) => `
        <div class="suggested-parlay" data-suggestion="${i}">
          <div class="suggested-header">
            <span class="suggested-name">${s.name}</span>
            <span class="suggested-odds">${formatOdds(s.odds)}</span>
          </div>
          <div class="suggested-legs">${s.legs.map(l => l.name).join(' + ')}</div>
          <div class="suggested-prob">${(s.prob * 100).toFixed(1)}% win probability</div>
        </div>
      `).join('');

      // Store for click handling
      window.suggestions = suggestions;

      container.querySelectorAll('.suggested-parlay').forEach(el => {
        el.addEventListener('click', () => {
          const idx = parseInt(el.dataset.suggestion);
          const suggestion = window.suggestions[idx];
          if (suggestion) {
            selectedLegs = [...suggestion.legs];
            renderLegs();
            renderSlip();
          }
        });
      });
    }

    function findBestCombination(legs, count) {
      // Find combination with best balance of probability and payout
      const combinations = getCombinations(legs, count);
      let best = null;
      let bestScore = -Infinity;

      combinations.forEach(combo => {
        const result = calculateParlayForLegs(combo);
        // Score: probability * log(odds) to balance both
        const score = result.prob * Math.log(Math.max(result.odds, 100));
        if (score > bestScore) {
          bestScore = score;
          best = { legs: combo, prob: result.prob, odds: result.odds };
        }
      });

      return best;
    }

    function getCombinations(arr, k) {
      const result = [];
      function combine(start, combo) {
        if (combo.length === k) {
          result.push([...combo]);
          return;
        }
        for (let i = start; i < arr.length; i++) {
          combo.push(arr[i]);
          combine(i + 1, combo);
          combo.pop();
        }
      }
      combine(0, []);
      return result;
    }

    function calculateParlayForLegs(legs) {
      let prob = 1;
      let decimal = 1;

      legs.forEach(leg => {
        prob *= leg.prob;
        decimal *= leg.odds > 0 ? (leg.odds / 100) + 1 : (100 / Math.abs(leg.odds)) + 1;
      });

      const odds = decimal >= 2
        ? Math.round((decimal - 1) * 100)
        : Math.round(-100 / (decimal - 1));

      return { prob, odds };
    }

    // Event listeners
    document.getElementById('matchup-select').addEventListener('change', (e) => {
      const val = e.target.value;
      if (!val) return;

      const [home, away, week] = val.split('|');
      selectedLegs = [];
      loadMatchupData(home, away, parseInt(week));
      renderSlip();
    });

    document.getElementById('clear-btn').addEventListener('click', () => {
      selectedLegs = [];
      renderLegs();
      renderSlip();
    });

    document.getElementById('wager-amount').addEventListener('input', () => {
      renderSlip();
    });

    // Filter event listeners
    document.getElementById('filter-type').addEventListener('change', (e) => {
      filters.type = e.target.value;
      renderLegs();
    });

    document.getElementById('filter-team').addEventListener('change', (e) => {
      filters.team = e.target.value;
      renderLegs();
    });

    document.getElementById('filter-stat').addEventListener('change', (e) => {
      filters.stat = e.target.value;
      renderLegs();
    });

    // Initialize
    initDB().catch(err => {
      console.error(err);
      document.getElementById('legs-container').innerHTML =
        '<div class="no-data">Error loading database</div>';
    });
  </script>
</body>
</html>
