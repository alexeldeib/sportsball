<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Parlay Builder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üèà</text></svg>" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500;600;700&family=Source+Sans+3:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.min.js"></script>
  <script src="odds-engine.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg-deep: #030712;
      --bg-card: #0c1322;
      --bg-hover: #111827;
      --bg-selected: #1e3a5f;
      --text-primary: #f1f5f9;
      --text-secondary: #94a3b8;
      --text-muted: #64748b;
      --border: #1e293b;
      --accent: #3b82f6;
      --positive: #22c55e;
      --negative: #ef4444;
      --warning: #d97706;
      --purple: #a855f7;
    }

    body {
      font-family: 'Source Sans 3', system-ui, sans-serif;
      background: var(--bg-deep);
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.5;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1.5rem 1rem 2rem;
    }

    header { text-align: center; margin-bottom: 1.5rem; }

    h1 {
      font-family: 'Oswald', sans-serif;
      font-size: 1.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.02em;
      margin-bottom: 0.25rem;
    }

    .subtitle { font-size: 0.9rem; color: var(--text-secondary); }

    .back-link {
      display: inline-block;
      color: var(--accent);
      text-decoration: none;
      font-size: 0.9rem;
      margin-bottom: 1rem;
    }
    .back-link:hover { text-decoration: underline; }

    .layout {
      display: grid;
      grid-template-columns: 1fr 350px;
      gap: 1.5rem;
    }

    @media (max-width: 900px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }

    .section {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 1rem;
      margin-bottom: 1rem;
    }

    .section-title {
      font-family: 'Oswald', sans-serif;
      font-size: 1rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .matchup-select {
      width: 100%;
      background: var(--bg-deep);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      padding: 0.75rem 1rem;
      font-family: inherit;
      font-size: 1rem;
      cursor: pointer;
      margin-bottom: 1rem;
    }

    .matchup-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    .legs-container {
      max-height: 60vh;
      overflow-y: auto;
    }

    .leg-group {
      margin-bottom: 1rem;
    }

    .leg-group-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--accent);
      margin-bottom: 0.5rem;
      padding-bottom: 0.25rem;
      border-bottom: 1px solid var(--border);
    }

    .leg-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.6rem 0.75rem;
      background: var(--bg-deep);
      border: 1px solid var(--border);
      border-radius: 6px;
      margin-bottom: 0.5rem;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .leg-item:hover {
      border-color: var(--accent);
      background: var(--bg-hover);
    }

    .leg-item.selected {
      border-color: var(--positive);
      background: rgba(34, 197, 94, 0.1);
    }

    .leg-item.selected .leg-checkbox {
      background: var(--positive);
      border-color: var(--positive);
    }

    .leg-checkbox {
      width: 18px;
      height: 18px;
      border: 2px solid var(--border);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      font-size: 0.75rem;
      color: white;
    }

    .leg-info {
      flex: 1;
      min-width: 0;
    }

    .leg-name {
      font-weight: 500;
      font-size: 0.9rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .leg-detail {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .leg-odds {
      font-family: 'Oswald', sans-serif;
      font-size: 0.95rem;
      font-weight: 500;
      color: var(--positive);
      white-space: nowrap;
    }

    .leg-prob {
      font-size: 0.75rem;
      color: var(--text-muted);
      text-align: right;
    }

    /* Parlay slip (right side) */
    .parlay-slip {
      position: sticky;
      top: 1rem;
    }

    .slip-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .clear-btn {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      padding: 0.35rem 0.75rem;
      border-radius: 4px;
      font-size: 0.8rem;
      cursor: pointer;
    }

    .clear-btn:hover {
      border-color: var(--negative);
      color: var(--negative);
    }

    .slip-legs {
      margin-bottom: 1rem;
    }

    .slip-leg {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
      border-bottom: 1px solid var(--border);
      font-size: 0.85rem;
    }

    .slip-leg:last-child {
      border-bottom: none;
    }

    .slip-leg-name {
      flex: 1;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-right: 0.5rem;
    }

    .slip-leg-odds {
      font-family: 'Oswald', sans-serif;
      color: var(--positive);
    }

    .slip-leg-remove {
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0.25rem;
      margin-left: 0.5rem;
    }

    .slip-leg-remove:hover {
      color: var(--negative);
    }

    .slip-empty {
      text-align: center;
      color: var(--text-muted);
      padding: 2rem 1rem;
      font-size: 0.9rem;
    }

    .slip-summary {
      background: var(--bg-deep);
      border-radius: 8px;
      padding: 1rem;
      margin-top: 1rem;
    }

    .summary-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    .summary-row:last-child {
      margin-bottom: 0;
    }

    .summary-label {
      color: var(--text-secondary);
    }

    .summary-value {
      font-weight: 600;
    }

    .summary-value.highlight {
      color: var(--positive);
      font-family: 'Oswald', sans-serif;
      font-size: 1.1rem;
    }

    .summary-value.warning {
      color: var(--warning);
    }

    .prob-bar {
      height: 6px;
      background: var(--bg-hover);
      border-radius: 3px;
      margin: 0.5rem 0;
      overflow: hidden;
    }

    .prob-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--positive), var(--warning));
      border-radius: 3px;
      transition: width 0.3s ease;
    }

    .wager-input {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 1rem;
    }

    .wager-input label {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .wager-input input {
      flex: 1;
      background: var(--bg-deep);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      padding: 0.5rem;
      font-family: inherit;
      font-size: 0.9rem;
      width: 80px;
    }

    .wager-input input:focus {
      outline: none;
      border-color: var(--accent);
    }

    /* Suggested parlays */
    .suggested-section {
      margin-top: 1.5rem;
    }

    .suggested-parlay {
      background: var(--bg-deep);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.75rem;
      margin-bottom: 0.75rem;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .suggested-parlay:hover {
      border-color: var(--accent);
    }

    .suggested-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .suggested-name {
      font-weight: 600;
      font-size: 0.9rem;
    }

    .suggested-odds {
      font-family: 'Oswald', sans-serif;
      color: var(--positive);
    }

    .suggested-legs {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .suggested-prob {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-top: 0.25rem;
    }

    .loading {
      text-align: center;
      color: var(--text-muted);
      padding: 2rem;
    }

    .no-data {
      text-align: center;
      color: var(--text-muted);
      padding: 1.5rem;
      font-size: 0.9rem;
    }

    /* Correlation warning */
    .correlation-warning {
      background: rgba(217, 119, 6, 0.1);
      border: 1px solid var(--warning);
      border-radius: 6px;
      padding: 0.75rem;
      margin-top: 1rem;
      font-size: 0.85rem;
      color: var(--warning);
    }

    /* Matchup indicators */
    .matchup-badge {
      display: inline-block;
      font-size: 0.65rem;
      font-weight: 600;
      text-transform: uppercase;
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      margin-left: 0.5rem;
    }
    .matchup-badge.smash {
      background: rgba(34, 197, 94, 0.2);
      color: var(--positive);
    }
    .matchup-badge.tough {
      background: rgba(239, 68, 68, 0.2);
      color: var(--negative);
    }
    .matchup-badge.neutral {
      background: rgba(148, 163, 184, 0.15);
      color: var(--text-muted);
    }

    /* Trend indicators */
    .trend-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.2rem;
      font-size: 0.65rem;
      font-weight: 600;
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      margin-left: 0.25rem;
    }
    .trend-badge.hot {
      background: rgba(239, 68, 68, 0.15);
      color: #f97316;
    }
    .trend-badge.cold {
      background: rgba(59, 130, 246, 0.15);
      color: #3b82f6;
    }

    /* Confidence indicator */
    .confidence-badge {
      display: inline-block;
      font-size: 0.6rem;
      font-weight: 700;
      padding: 0.1rem 0.35rem;
      border-radius: 3px;
      margin-left: 0.25rem;
      background: rgba(168, 85, 247, 0.2);
      color: var(--purple);
    }

    /* Correlation details */
    .correlation-details {
      background: var(--bg-deep);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.75rem;
      margin-top: 0.75rem;
      font-size: 0.8rem;
    }
    .correlation-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.35rem 0;
      border-bottom: 1px solid var(--border);
    }
    .correlation-row:last-child { border-bottom: none; }
    .correlation-boost {
      color: var(--positive);
      font-weight: 600;
    }
    .correlation-conflict {
      color: var(--negative);
      font-weight: 600;
    }

    /* H2H context */
    .h2h-context {
      background: rgba(59, 130, 246, 0.1);
      border: 1px solid var(--accent);
      border-radius: 6px;
      padding: 0.6rem 0.75rem;
      margin-bottom: 0.75rem;
      font-size: 0.8rem;
    }
    .h2h-context-title {
      font-weight: 600;
      color: var(--accent);
      margin-bottom: 0.25rem;
    }
    .h2h-context-stat {
      color: var(--text-secondary);
    }
    .h2h-context-stat span {
      color: var(--text-primary);
      font-weight: 500;
    }

    /* Leg detail enhancement */
    .leg-detail {
      font-size: 0.8rem;
      color: var(--text-muted);
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.25rem;
    }

    /* Market odds input in slip */
    .slip-leg-market {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      margin-top: 0.25rem;
      font-size: 0.75rem;
    }
    .slip-leg-market label {
      color: var(--text-muted);
    }
    .slip-leg-market input {
      width: 60px;
      background: var(--bg-deep);
      border: 1px solid var(--border);
      border-radius: 3px;
      color: var(--text-primary);
      padding: 0.2rem 0.35rem;
      font-family: inherit;
      font-size: 0.75rem;
      text-align: center;
    }
    .slip-leg-market input:focus {
      outline: none;
      border-color: var(--accent);
    }
    .edge-indicator {
      font-weight: 600;
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
      font-size: 0.7rem;
    }
    .edge-indicator.positive {
      background: rgba(34, 197, 94, 0.15);
      color: var(--positive);
    }
    .edge-indicator.negative {
      background: rgba(239, 68, 68, 0.15);
      color: var(--negative);
    }
  </style>
</head>
<body>
  <div class="container">
    <a href="index.html" class="back-link">&larr; Back to Home</a>

    <header>
      <h1>Parlay Builder</h1>
      <p class="subtitle">Build multi-leg parlays with game and player props</p>
    </header>

    <div class="layout">
      <div class="main-content">
        <div class="section">
          <div class="section-title">Select Matchup</div>
          <select id="matchup-select" class="matchup-select">
            <option value="">Loading matchups...</option>
          </select>
        </div>

        <div id="legs-section" class="section" style="display: none;">
          <div class="section-title">Available Legs</div>
          <div id="legs-container" class="legs-container">
            <div class="loading">Select a matchup to see available legs</div>
          </div>
        </div>

        <div id="suggested-section" class="section suggested-section" style="display: none;">
          <div class="section-title">Suggested Parlays</div>
          <div id="suggested-container"></div>
        </div>
      </div>

      <div class="parlay-slip section">
        <div class="slip-header">
          <div class="section-title" style="margin-bottom: 0;">Parlay Slip</div>
          <button id="clear-btn" class="clear-btn">Clear</button>
        </div>

        <div id="slip-legs" class="slip-legs">
          <div class="slip-empty">Add 2+ legs to build a parlay</div>
        </div>

        <div id="slip-summary" class="slip-summary" style="display: none;">
          <div class="summary-row">
            <span class="summary-label">Legs</span>
            <span id="leg-count" class="summary-value">0</span>
          </div>
          <div class="summary-row">
            <span class="summary-label">Combined Odds</span>
            <span id="combined-odds" class="summary-value highlight">+100</span>
          </div>
          <div class="summary-row">
            <span class="summary-label">Win Probability</span>
            <span id="win-prob" class="summary-value">50%</span>
          </div>
          <div class="prob-bar">
            <div id="prob-fill" class="prob-fill" style="width: 50%;"></div>
          </div>
          <div class="wager-input">
            <label>Wager $</label>
            <input type="number" id="wager-amount" value="10" min="1">
            <span class="summary-label">To win:</span>
            <span id="potential-win" class="summary-value highlight">$10</span>
          </div>
        </div>

        <div id="correlation-warning" class="correlation-warning" style="display: none;">
          Correlated legs detected. Actual probability may differ.
        </div>
      </div>
    </div>
  </div>

  <script>
    let db = null;
    let currentMatchup = null;
    let selectedLegs = [];
    let availableLegs = [];
    let defenseRankings = {};  // position -> stat -> { team: rank }
    let h2hData = null;
    let marketOdds = {};  // legId -> market odds entered by user

    async function initDB() {
      const SQL = await initSqlJs({
        locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}`
      });

      const response = await fetch('nfl.db?' + Date.now());
      const buffer = await response.arrayBuffer();
      db = new SQL.Database(new Uint8Array(buffer));

      // Load advanced stats for odds engine
      await OddsEngine.loadAdvancedStats(2025);

      // Calculate defense rankings
      calculateDefenseRankings();

      loadMatchups();
    }

    function calculateDefenseRankings() {
      // Calculate how much each defense allows by position/stat
      // Lower rank = tougher defense, Higher rank = easier matchup
      const stats = ['pass_yd', 'rush_yd', 'rec_yd', 'rec'];
      const positions = ['QB', 'RB', 'WR', 'TE'];

      positions.forEach(pos => {
        defenseRankings[pos] = {};
        stats.forEach(stat => {
          defenseRankings[pos][stat] = {};
        });
      });

      // Query average stats allowed by each defense, grouped by position
      const result = db.exec(`
        SELECT
          opponent as team,
          position,
          AVG(pass_yd) as avg_pass_yd,
          AVG(rush_yd) as avg_rush_yd,
          AVG(rec_yd) as avg_rec_yd,
          AVG(rec) as avg_rec,
          COUNT(DISTINCT player_id) as players
        FROM player_weekly_stats
        WHERE season = 2025 AND position IN ('QB', 'RB', 'WR', 'TE')
        GROUP BY opponent, position
        HAVING players >= 3
      `);

      if (!result.length) return;

      const cols = result[0].columns;
      const byPosTeam = {};

      result[0].values.forEach(vals => {
        const row = {};
        cols.forEach((c, i) => row[c] = vals[i]);
        const key = `${row.position}_${row.team}`;
        byPosTeam[key] = row;
      });

      // Rank each team for each position/stat
      positions.forEach(pos => {
        stats.forEach(stat => {
          const teams = Object.values(byPosTeam)
            .filter(r => r.position === pos && r[`avg_${stat}`] != null)
            .sort((a, b) => (b[`avg_${stat}`] || 0) - (a[`avg_${stat}`] || 0)); // Higher allowed = easier

          teams.forEach((t, idx) => {
            defenseRankings[pos][stat][t.team] = {
              rank: idx + 1,
              allowed: t[`avg_${stat}`],
              total: teams.length
            };
          });
        });
      });
    }

    function getMatchupQuality(position, stat, opponent) {
      if (!defenseRankings[position] || !defenseRankings[position][stat]) return null;

      const data = defenseRankings[position][stat][opponent];
      if (!data) return null;

      const pct = data.rank / data.total;  // Lower = easier (allows more)
      return {
        rank: data.rank,
        total: data.total,
        quality: pct <= 0.25 ? 'smash' : pct >= 0.75 ? 'tough' : 'neutral',
        allowed: data.allowed
      };
    }

    function getPlayerTrend(playerName) {
      // Get last 3 games and compare to season average
      const result = db.exec(`
        SELECT
          pts_ppr,
          week,
          (SELECT AVG(pts_ppr) FROM player_weekly_stats WHERE player_name = p.player_name AND season = 2025) as season_avg
        FROM player_weekly_stats p
        WHERE player_name = '${playerName.replace(/'/g, "''")}' AND season = 2025
        ORDER BY week DESC
        LIMIT 3
      `);

      if (!result.length || result[0].values.length < 3) return null;

      const cols = result[0].columns;
      const games = result[0].values.map(vals => {
        const obj = {};
        cols.forEach((c, i) => obj[c] = vals[i]);
        return obj;
      });

      const last3Avg = games.reduce((s, g) => s + (g.pts_ppr || 0), 0) / games.length;
      const seasonAvg = games[0].season_avg || 0;

      if (seasonAvg === 0) return null;

      const diff = (last3Avg - seasonAvg) / seasonAvg;
      if (diff >= 0.15) return { trend: 'hot', pct: diff };
      if (diff <= -0.15) return { trend: 'cold', pct: diff };
      return null;
    }

    function loadH2HContext(home, away) {
      // Get historical matchup data for game totals context
      const result = db.exec(`
        SELECT
          home_score + away_score as total,
          home_score,
          away_score,
          season,
          week
        FROM games
        WHERE ((home_team = '${home}' AND away_team = '${away}')
           OR (home_team = '${away}' AND away_team = '${home}'))
          AND is_completed = 1
        ORDER BY season DESC, week DESC
        LIMIT 10
      `);

      if (!result.length || !result[0].values.length) {
        h2hData = null;
        return;
      }

      const cols = result[0].columns;
      const games = result[0].values.map(vals => {
        const obj = {};
        cols.forEach((c, i) => obj[c] = vals[i]);
        return obj;
      });

      const totals = games.map(g => g.total).filter(t => t > 0);
      const avgTotal = totals.length ? totals.reduce((a, b) => a + b, 0) / totals.length : 0;
      const overCount = totals.filter(t => t > 44).length;  // League avg ~44

      h2hData = {
        games: games.length,
        avgTotal: avgTotal.toFixed(1),
        overRate: totals.length ? ((overCount / totals.length) * 100).toFixed(0) : 0,
        lastGame: games[0]
      };
    }

    function loadMatchups() {
      const result = db.exec(`
        SELECT week, home_team, away_team, game_date
        FROM games
        WHERE season = 2025 AND is_completed = 0
        ORDER BY week, game_date
      `);

      const select = document.getElementById('matchup-select');
      select.innerHTML = '<option value="">Select a matchup...</option>';

      if (result.length && result[0].values) {
        result[0].values.forEach(([week, home, away, date]) => {
          const opt = document.createElement('option');
          opt.value = `${home}|${away}|${week}`;
          opt.textContent = `Week ${week}: ${away} @ ${home}`;
          select.appendChild(opt);
        });
      }
    }

    function loadMatchupData(home, away, week) {
      currentMatchup = { home, away, week };
      availableLegs = [];

      // Load H2H context for game totals
      loadH2HContext(home, away);

      // Get team stats
      const homeStats = getTeamStats(home);
      const awayStats = getTeamStats(away);

      // Calculate game odds
      const gameOdds = OddsEngine.calculateMatchupOdds(homeStats, awayStats);

      // Build game legs
      const gameLegs = buildGameLegs(home, away, gameOdds);

      // Get player props (pass opponent for matchup adjustment)
      const playerLegs = buildPlayerLegs(home, away);

      availableLegs = [...gameLegs, ...playerLegs];

      renderLegs();
      generateSuggestedParlays();
    }

    function getTeamStats(team) {
      const result = db.exec(`
        SELECT * FROM team_stats WHERE team_code = '${team}' AND season = 2025
      `);

      if (result.length && result[0].values.length) {
        const cols = result[0].columns;
        const vals = result[0].values[0];
        const stats = {};
        cols.forEach((col, i) => stats[col] = vals[i]);
        return stats;
      }
      return null;
    }

    function buildGameLegs(home, away, odds) {
      const legs = [];

      // Moneyline
      legs.push({
        id: `ml_${home}`,
        type: 'game',
        category: 'Moneyline',
        name: `${home} to win`,
        detail: 'Moneyline',
        odds: odds.homeMoneyline,
        prob: odds.homeWinProb,
        team: home
      });

      legs.push({
        id: `ml_${away}`,
        type: 'game',
        category: 'Moneyline',
        name: `${away} to win`,
        detail: 'Moneyline',
        odds: odds.awayMoneyline,
        prob: odds.awayWinProb,
        team: away
      });

      // Spread
      const homeSpreadOdds = odds.spread <= 0 ? -110 : -110;
      const awaySpreadOdds = -110;
      const spreadProb = 0.5; // Simplified

      legs.push({
        id: `spread_${home}`,
        type: 'game',
        category: 'Spread',
        name: `${home} ${OddsEngine.formatSpread(odds.spread)}`,
        detail: 'Spread',
        odds: homeSpreadOdds,
        prob: spreadProb,
        team: home
      });

      legs.push({
        id: `spread_${away}`,
        type: 'game',
        category: 'Spread',
        name: `${away} ${OddsEngine.formatSpread(-odds.spread)}`,
        detail: 'Spread',
        odds: awaySpreadOdds,
        prob: spreadProb,
        team: away
      });

      // Over/Under
      legs.push({
        id: 'over',
        type: 'game',
        category: 'Total',
        name: `Over ${odds.overUnder}`,
        detail: 'Game Total',
        odds: -110,
        prob: 0.5,
        team: null
      });

      legs.push({
        id: 'under',
        type: 'game',
        category: 'Total',
        name: `Under ${odds.overUnder}`,
        detail: 'Game Total',
        odds: -110,
        prob: 0.5,
        team: null
      });

      return legs;
    }

    function buildPlayerLegs(home, away) {
      const legs = [];

      // Get key players from both teams
      const players = db.exec(`
        SELECT
          player_name,
          team,
          position,
          AVG(pass_yd) as avg_pass_yd,
          AVG(rush_yd) as avg_rush_yd,
          AVG(rec_yd) as avg_rec_yd,
          AVG(rec) as avg_rec,
          SUM(pass_td) as total_pass_td,
          SUM(rush_td) as total_rush_td,
          SUM(rec_td) as total_rec_td,
          COUNT(*) as games,
          STDEV(pass_yd) as std_pass_yd,
          STDEV(rush_yd) as std_rush_yd,
          STDEV(rec_yd) as std_rec_yd
        FROM player_weekly_stats
        WHERE season = 2025
          AND team IN ('${home}', '${away}')
          AND position IN ('QB', 'RB', 'WR', 'TE')
        GROUP BY player_id
        HAVING games >= 4
        ORDER BY
          CASE position
            WHEN 'QB' THEN 1
            WHEN 'RB' THEN 2
            WHEN 'WR' THEN 3
            WHEN 'TE' THEN 4
          END,
          (COALESCE(avg_pass_yd, 0) + COALESCE(avg_rush_yd, 0) + COALESCE(avg_rec_yd, 0)) DESC
      `);

      if (!players.length || !players[0].values.length) return legs;

      const cols = players[0].columns;
      players[0].values.forEach(vals => {
        const p = {};
        cols.forEach((col, i) => p[col] = vals[i]);

        // Skip players with low volume
        if (p.games < 4) return;

        // Determine opponent for this player
        const opponent = p.team === home ? away : home;

        // Get player trend
        const trend = getPlayerTrend(p.player_name);

        // QB passing yards
        if (p.position === 'QB' && p.avg_pass_yd > 150) {
          const matchup = getMatchupQuality('QB', 'pass_yd', opponent);
          const line = roundToHalf(p.avg_pass_yd);
          let { overProb, overOdds, underOdds } = calculatePropOdds(p.avg_pass_yd, p.std_pass_yd || 50, line);

          // Adjust probability based on matchup quality
          if (matchup) {
            if (matchup.quality === 'smash') overProb = Math.min(0.78, overProb + 0.08);
            if (matchup.quality === 'tough') overProb = Math.max(0.22, overProb - 0.08);
            overOdds = probToOdds(overProb);
            underOdds = probToOdds(1 - overProb);
          }

          legs.push({
            id: `pass_yd_over_${p.player_name}`,
            type: 'player',
            category: `${p.team} Players`,
            name: `${p.player_name} Over ${line} pass yds`,
            detail: `Avg: ${p.avg_pass_yd.toFixed(0)}`,
            odds: overOdds,
            prob: overProb,
            team: p.team,
            player: p.player_name,
            stat: 'pass_yd',
            position: 'QB',
            matchup: matchup,
            trend: trend
          });

          legs.push({
            id: `pass_yd_under_${p.player_name}`,
            type: 'player',
            category: `${p.team} Players`,
            name: `${p.player_name} Under ${line} pass yds`,
            detail: `Avg: ${p.avg_pass_yd.toFixed(0)}`,
            odds: underOdds,
            prob: 1 - overProb,
            team: p.team,
            player: p.player_name,
            stat: 'pass_yd',
            position: 'QB',
            matchup: matchup ? { ...matchup, quality: matchup.quality === 'smash' ? 'tough' : matchup.quality === 'tough' ? 'smash' : 'neutral' } : null,
            trend: trend
          });

          // Passing TDs
          const tdRate = p.total_pass_td / p.games;
          if (tdRate > 1) {
            const tdLine = 1.5;
            let tdProb = tdRate > tdLine ? 0.55 + (tdRate - tdLine) * 0.1 : 0.45;
            if (matchup && matchup.quality === 'smash') tdProb = Math.min(0.75, tdProb + 0.05);
            if (matchup && matchup.quality === 'tough') tdProb = Math.max(0.3, tdProb - 0.05);

            legs.push({
              id: `pass_td_over_${p.player_name}`,
              type: 'player',
              category: `${p.team} Players`,
              name: `${p.player_name} Over 1.5 pass TDs`,
              detail: `Avg: ${tdRate.toFixed(1)}/game`,
              odds: probToOdds(tdProb),
              prob: tdProb,
              team: p.team,
              player: p.player_name,
              stat: 'pass_td',
              position: 'QB',
              matchup: matchup,
              trend: trend
            });
          }
        }

        // RB rushing yards
        if ((p.position === 'RB' || p.position === 'QB') && p.avg_rush_yd > 30) {
          const matchup = getMatchupQuality(p.position === 'RB' ? 'RB' : 'QB', 'rush_yd', opponent);
          const line = roundToHalf(p.avg_rush_yd);
          let { overProb, overOdds, underOdds } = calculatePropOdds(p.avg_rush_yd, p.std_rush_yd || 20, line);

          if (matchup) {
            if (matchup.quality === 'smash') overProb = Math.min(0.78, overProb + 0.08);
            if (matchup.quality === 'tough') overProb = Math.max(0.22, overProb - 0.08);
            overOdds = probToOdds(overProb);
            underOdds = probToOdds(1 - overProb);
          }

          legs.push({
            id: `rush_yd_over_${p.player_name}`,
            type: 'player',
            category: `${p.team} Players`,
            name: `${p.player_name} Over ${line} rush yds`,
            detail: `Avg: ${p.avg_rush_yd.toFixed(0)}`,
            odds: overOdds,
            prob: overProb,
            team: p.team,
            player: p.player_name,
            stat: 'rush_yd',
            position: p.position,
            matchup: matchup,
            trend: trend
          });

          legs.push({
            id: `rush_yd_under_${p.player_name}`,
            type: 'player',
            category: `${p.team} Players`,
            name: `${p.player_name} Under ${line} rush yds`,
            detail: `Avg: ${p.avg_rush_yd.toFixed(0)}`,
            odds: underOdds,
            prob: 1 - overProb,
            team: p.team,
            player: p.player_name,
            stat: 'rush_yd',
            position: p.position,
            matchup: matchup ? { ...matchup, quality: matchup.quality === 'smash' ? 'tough' : matchup.quality === 'tough' ? 'smash' : 'neutral' } : null,
            trend: trend
          });
        }

        // WR/TE/RB receiving yards
        if (p.avg_rec_yd > 25) {
          const matchup = getMatchupQuality(p.position, 'rec_yd', opponent);
          const line = roundToHalf(p.avg_rec_yd);
          let { overProb, overOdds, underOdds } = calculatePropOdds(p.avg_rec_yd, p.std_rec_yd || 25, line);

          if (matchup) {
            if (matchup.quality === 'smash') overProb = Math.min(0.78, overProb + 0.08);
            if (matchup.quality === 'tough') overProb = Math.max(0.22, overProb - 0.08);
            overOdds = probToOdds(overProb);
            underOdds = probToOdds(1 - overProb);
          }

          legs.push({
            id: `rec_yd_over_${p.player_name}`,
            type: 'player',
            category: `${p.team} Players`,
            name: `${p.player_name} Over ${line} rec yds`,
            detail: `Avg: ${p.avg_rec_yd.toFixed(0)}`,
            odds: overOdds,
            prob: overProb,
            team: p.team,
            player: p.player_name,
            stat: 'rec_yd',
            position: p.position,
            matchup: matchup,
            trend: trend
          });

          legs.push({
            id: `rec_yd_under_${p.player_name}`,
            type: 'player',
            category: `${p.team} Players`,
            name: `${p.player_name} Under ${line} rec yds`,
            detail: `Avg: ${p.avg_rec_yd.toFixed(0)}`,
            odds: underOdds,
            prob: 1 - overProb,
            team: p.team,
            player: p.player_name,
            stat: 'rec_yd',
            position: p.position,
            matchup: matchup ? { ...matchup, quality: matchup.quality === 'smash' ? 'tough' : matchup.quality === 'tough' ? 'smash' : 'neutral' } : null,
            trend: trend
          });
        }

        // Receptions
        if (p.avg_rec > 3) {
          const matchup = getMatchupQuality(p.position, 'rec', opponent);
          const line = roundToHalf(p.avg_rec);
          let { overProb, overOdds, underOdds } = calculatePropOdds(p.avg_rec, 2, line);

          if (matchup) {
            if (matchup.quality === 'smash') overProb = Math.min(0.78, overProb + 0.06);
            if (matchup.quality === 'tough') overProb = Math.max(0.22, overProb - 0.06);
            overOdds = probToOdds(overProb);
          }

          legs.push({
            id: `rec_over_${p.player_name}`,
            type: 'player',
            category: `${p.team} Players`,
            name: `${p.player_name} Over ${line} receptions`,
            detail: `Avg: ${p.avg_rec.toFixed(1)}`,
            odds: overOdds,
            prob: overProb,
            team: p.team,
            player: p.player_name,
            stat: 'rec',
            position: p.position,
            matchup: matchup,
            trend: trend
          });
        }

        // Anytime TD scorer
        const tdRate = (p.total_rush_td + p.total_rec_td) / p.games;
        if (tdRate > 0.3 && (p.position === 'RB' || p.position === 'WR' || p.position === 'TE')) {
          let tdProb = Math.min(0.85, tdRate * 0.7 + 0.1);
          // Boost TD prob slightly for good matchups
          const matchup = getMatchupQuality(p.position, p.position === 'RB' ? 'rush_yd' : 'rec_yd', opponent);
          if (matchup && matchup.quality === 'smash') tdProb = Math.min(0.85, tdProb + 0.05);
          if (matchup && matchup.quality === 'tough') tdProb = Math.max(0.2, tdProb - 0.05);

          legs.push({
            id: `atd_${p.player_name}`,
            type: 'player',
            category: `${p.team} Players`,
            name: `${p.player_name} Anytime TD`,
            detail: `${(tdRate * 100).toFixed(0)}% TD rate`,
            odds: probToOdds(tdProb),
            prob: tdProb,
            team: p.team,
            player: p.player_name,
            stat: 'td',
            position: p.position,
            matchup: matchup,
            trend: trend
          });
        }
      });

      return legs;
    }

    function calculatePropOdds(avg, std, line) {
      // Use normal distribution CDF approximation
      const z = (line - avg) / (std || 1);
      const overProb = 1 - normalCDF(z);

      // Clamp probability
      const clampedOver = Math.max(0.2, Math.min(0.8, overProb));

      return {
        overProb: clampedOver,
        overOdds: probToOdds(clampedOver),
        underOdds: probToOdds(1 - clampedOver)
      };
    }

    function normalCDF(z) {
      // Approximation of standard normal CDF
      const a1 = 0.254829592;
      const a2 = -0.284496736;
      const a3 = 1.421413741;
      const a4 = -1.453152027;
      const a5 = 1.061405429;
      const p = 0.3275911;

      const sign = z < 0 ? -1 : 1;
      z = Math.abs(z) / Math.sqrt(2);

      const t = 1.0 / (1.0 + p * z);
      const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-z * z);

      return 0.5 * (1.0 + sign * y);
    }

    function probToOdds(prob) {
      if (prob >= 0.5) {
        return Math.round(-100 * prob / (1 - prob));
      } else {
        return Math.round(100 * (1 - prob) / prob);
      }
    }

    function roundToHalf(n) {
      return Math.round(n * 2) / 2;
    }

    function renderLegs() {
      const container = document.getElementById('legs-container');
      document.getElementById('legs-section').style.display = 'block';

      if (availableLegs.length === 0) {
        container.innerHTML = '<div class="no-data">No legs available for this matchup</div>';
        return;
      }

      // Show H2H context if available (before game legs)
      let html = '';
      if (h2hData && h2hData.games > 0) {
        html += `
          <div class="h2h-context">
            <div class="h2h-context-title">H2H History (${h2hData.games} games)</div>
            <div class="h2h-context-stat">Avg Total: <span>${h2hData.avgTotal} pts</span> | Over 44 rate: <span>${h2hData.overRate}%</span></div>
          </div>
        `;
      }

      // Group by category
      const groups = {};
      availableLegs.forEach(leg => {
        if (!groups[leg.category]) groups[leg.category] = [];
        groups[leg.category].push(leg);
      });

      for (const [category, legs] of Object.entries(groups)) {
        html += `<div class="leg-group">
          <div class="leg-group-title">${category}</div>`;

        legs.forEach(leg => {
          const isSelected = selectedLegs.some(l => l.id === leg.id);

          // Build badges
          let badges = '';
          if (leg.matchup) {
            const label = leg.matchup.quality === 'smash' ? 'Smash'
                        : leg.matchup.quality === 'tough' ? 'Tough' : '';
            if (label) {
              badges += `<span class="matchup-badge ${leg.matchup.quality}">${label}</span>`;
            }
          }
          if (leg.trend) {
            const icon = leg.trend.trend === 'hot' ? 'üî•' : '‚ùÑÔ∏è';
            badges += `<span class="trend-badge ${leg.trend.trend}">${icon} ${leg.trend.trend.toUpperCase()}</span>`;
          }
          if (leg.prob >= 0.62) {
            badges += `<span class="confidence-badge">HIGH CONF</span>`;
          }

          html += `
            <div class="leg-item ${isSelected ? 'selected' : ''}" data-leg-id="${leg.id}">
              <div class="leg-checkbox">${isSelected ? '‚úì' : ''}</div>
              <div class="leg-info">
                <div class="leg-name">${leg.name}${badges}</div>
                <div class="leg-detail">${leg.detail}</div>
              </div>
              <div>
                <div class="leg-odds">${formatOdds(leg.odds)}</div>
                <div class="leg-prob">${(leg.prob * 100).toFixed(0)}%</div>
              </div>
            </div>
          `;
        });

        html += '</div>';
      }

      container.innerHTML = html;

      // Add click handlers
      container.querySelectorAll('.leg-item').forEach(el => {
        el.addEventListener('click', () => {
          const legId = el.dataset.legId;
          toggleLeg(legId);
        });
      });
    }

    function toggleLeg(legId) {
      const leg = availableLegs.find(l => l.id === legId);
      if (!leg) return;

      const idx = selectedLegs.findIndex(l => l.id === legId);
      if (idx >= 0) {
        selectedLegs.splice(idx, 1);
      } else {
        // Check for conflicting legs
        const conflicting = selectedLegs.findIndex(l => isConflicting(l, leg));
        if (conflicting >= 0) {
          selectedLegs.splice(conflicting, 1);
        }
        selectedLegs.push(leg);
      }

      renderLegs();
      renderSlip();
    }

    function isConflicting(leg1, leg2) {
      // Same game leg type (can't have both ML, both spreads, etc.)
      if (leg1.type === 'game' && leg2.type === 'game') {
        if (leg1.category === leg2.category) return true;
      }

      // Same player, same stat (over vs under)
      if (leg1.type === 'player' && leg2.type === 'player') {
        if (leg1.player === leg2.player && leg1.stat === leg2.stat) return true;
      }

      return false;
    }

    function renderSlip() {
      const legsContainer = document.getElementById('slip-legs');
      const summary = document.getElementById('slip-summary');
      const warning = document.getElementById('correlation-warning');

      if (selectedLegs.length === 0) {
        legsContainer.innerHTML = '<div class="slip-empty">Add 2+ legs to build a parlay</div>';
        summary.style.display = 'none';
        warning.style.display = 'none';
        return;
      }

      let html = '';
      selectedLegs.forEach(leg => {
        const mktOdds = marketOdds[leg.id];
        const edge = mktOdds ? calculateEdge(leg.prob, mktOdds) : null;
        const edgeHtml = edge !== null
          ? `<span class="edge-indicator ${edge >= 0 ? 'positive' : 'negative'}">${edge >= 0 ? '+' : ''}${edge.toFixed(1)}%</span>`
          : '';

        html += `
          <div class="slip-leg">
            <div style="flex: 1; min-width: 0;">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <span class="slip-leg-name">${leg.name}</span>
                <span class="slip-leg-odds">${formatOdds(leg.odds)}</span>
              </div>
              <div class="slip-leg-market">
                <label>Market:</label>
                <input type="text" class="market-odds-input" data-leg-id="${leg.id}"
                       value="${mktOdds || ''}" placeholder="+/-odds">
                ${edgeHtml}
              </div>
            </div>
            <button class="slip-leg-remove" data-leg-id="${leg.id}">&times;</button>
          </div>
        `;
      });
      legsContainer.innerHTML = html;

      // Add remove handlers
      legsContainer.querySelectorAll('.slip-leg-remove').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const legId = btn.dataset.legId;
          selectedLegs = selectedLegs.filter(l => l.id !== legId);
          delete marketOdds[legId];
          renderLegs();
          renderSlip();
        });
      });

      // Add market odds input handlers
      legsContainer.querySelectorAll('.market-odds-input').forEach(input => {
        input.addEventListener('change', (e) => {
          const legId = e.target.dataset.legId;
          const value = e.target.value.trim();
          if (value && !isNaN(parseInt(value))) {
            marketOdds[legId] = parseInt(value);
          } else {
            delete marketOdds[legId];
          }
          renderSlip();
        });
      });

      // Calculate parlay
      const { combinedProb, combinedOdds, payout } = calculateParlay();

      document.getElementById('leg-count').textContent = selectedLegs.length;
      document.getElementById('combined-odds').textContent = formatOdds(combinedOdds);
      document.getElementById('win-prob').textContent = `${(combinedProb * 100).toFixed(1)}%`;
      document.getElementById('win-prob').className = `summary-value ${combinedProb < 0.1 ? 'warning' : ''}`;
      document.getElementById('prob-fill').style.width = `${combinedProb * 100}%`;

      const wager = parseFloat(document.getElementById('wager-amount').value) || 10;
      document.getElementById('potential-win').textContent = `$${payout.toFixed(2)}`;

      summary.style.display = selectedLegs.length >= 2 ? 'block' : 'none';

      // Check for correlations and show details
      const { hasCorrelation, correlations } = checkCorrelations();
      if (hasCorrelation && correlations.length > 0) {
        let corrHtml = '<div class="correlation-warning">Correlated legs detected:</div>';
        corrHtml += '<div class="correlation-details">';
        correlations.forEach(c => {
          const effectClass = c.effect === 'boost' ? 'correlation-boost' : 'correlation-conflict';
          corrHtml += `
            <div class="correlation-row">
              <span>${c.description}</span>
              <span class="${effectClass}">${c.adjustment}</span>
            </div>
          `;
        });
        corrHtml += '</div>';
        warning.innerHTML = corrHtml;
        warning.style.display = 'block';
      } else {
        warning.style.display = 'none';
      }
    }

    function calculateParlay() {
      if (selectedLegs.length === 0) {
        return { combinedProb: 0, combinedOdds: 0, payout: 0 };
      }

      // Combined probability (assuming independence)
      let combinedProb = 1;
      selectedLegs.forEach(leg => {
        combinedProb *= leg.prob;
      });

      // Combined decimal odds
      let decimalMultiplier = 1;
      selectedLegs.forEach(leg => {
        const decimal = leg.odds > 0 ? (leg.odds / 100) + 1 : (100 / Math.abs(leg.odds)) + 1;
        decimalMultiplier *= decimal;
      });

      // Convert back to American
      const combinedOdds = decimalMultiplier >= 2
        ? Math.round((decimalMultiplier - 1) * 100)
        : Math.round(-100 / (decimalMultiplier - 1));

      const wager = parseFloat(document.getElementById('wager-amount').value) || 10;
      const payout = wager * (decimalMultiplier - 1);

      return { combinedProb, combinedOdds, payout };
    }

    function checkCorrelations() {
      // Returns object with hasCorrelation flag and detailed analysis
      const correlations = [];

      // Multiple legs from same player
      const playerLegs = selectedLegs.filter(l => l.player);
      const playerCounts = {};
      playerLegs.forEach(l => {
        playerCounts[l.player] = (playerCounts[l.player] || 0) + 1;
      });
      Object.entries(playerCounts).forEach(([player, count]) => {
        if (count > 1) {
          const legs = playerLegs.filter(l => l.player === player);
          correlations.push({
            type: 'same-player',
            description: `${player}: ${legs.map(l => l.stat).join(' + ')}`,
            effect: 'boost',
            adjustment: '+5-10%'
          });
        }
      });

      // Game total + player yards (positive correlation)
      const hasOver = selectedLegs.some(l => l.id === 'over');
      const hasUnder = selectedLegs.some(l => l.id === 'under');
      const yardLegs = selectedLegs.filter(l => l.stat && l.stat.includes('yd') && l.id.includes('over'));
      const underYardLegs = selectedLegs.filter(l => l.stat && l.stat.includes('yd') && l.id.includes('under'));

      if (hasOver && yardLegs.length > 0) {
        correlations.push({
          type: 'total-yards',
          description: `Over + ${yardLegs.length} yardage overs`,
          effect: 'boost',
          adjustment: '+8-12%'
        });
      }
      if (hasUnder && underYardLegs.length > 0) {
        correlations.push({
          type: 'total-yards',
          description: `Under + ${underYardLegs.length} yardage unders`,
          effect: 'boost',
          adjustment: '+8-12%'
        });
      }
      if (hasOver && underYardLegs.length > 0) {
        correlations.push({
          type: 'conflict',
          description: `Over + yardage unders conflict`,
          effect: 'conflict',
          adjustment: '-10-15%'
        });
      }
      if (hasUnder && yardLegs.length > 0) {
        correlations.push({
          type: 'conflict',
          description: `Under + yardage overs conflict`,
          effect: 'conflict',
          adjustment: '-10-15%'
        });
      }

      // Team win + team player props (positive correlation)
      const mlLegs = selectedLegs.filter(l => l.id && l.id.startsWith('ml_'));
      mlLegs.forEach(ml => {
        const teamPlayerOvers = selectedLegs.filter(l =>
          l.type === 'player' && l.team === ml.team && l.id && l.id.includes('over')
        );
        if (teamPlayerOvers.length > 0) {
          correlations.push({
            type: 'team-player',
            description: `${ml.team} ML + ${teamPlayerOvers.length} player overs`,
            effect: 'boost',
            adjustment: '+5-8%'
          });
        }
      });

      return {
        hasCorrelation: correlations.length > 0,
        correlations: correlations
      };
    }

    function calculateEdge(modelProb, marketOdds) {
      // Convert market odds to implied probability
      let impliedProb;
      if (marketOdds > 0) {
        impliedProb = 100 / (marketOdds + 100);
      } else {
        impliedProb = Math.abs(marketOdds) / (Math.abs(marketOdds) + 100);
      }

      // Edge = model probability - implied probability
      return (modelProb - impliedProb) * 100;
    }

    function formatOdds(odds) {
      if (odds > 0) return '+' + odds;
      return String(odds);
    }

    function generateSuggestedParlays() {
      const container = document.getElementById('suggested-container');
      document.getElementById('suggested-section').style.display = 'block';

      if (availableLegs.length < 3) {
        container.innerHTML = '<div class="no-data">Not enough legs available</div>';
        return;
      }

      const suggestions = [];

      // Find high-probability legs (55-70%)
      const highProbLegs = availableLegs.filter(l => l.prob >= 0.52 && l.prob <= 0.72);

      // Strategy 1: "Safe" parlay - 3 highest probability legs
      const safeLegs = [...availableLegs]
        .filter(l => l.prob >= 0.5)
        .sort((a, b) => b.prob - a.prob)
        .slice(0, 4);

      if (safeLegs.length >= 3) {
        const safePick = findBestCombination(safeLegs, 3);
        if (safePick) {
          suggestions.push({
            name: 'Conservative',
            legs: safePick.legs,
            prob: safePick.prob,
            odds: safePick.odds
          });
        }
      }

      // Strategy 2: "Balanced" - mix of game and player props
      const gameLegs = availableLegs.filter(l => l.type === 'game' && l.prob >= 0.45);
      const playerLegs = availableLegs.filter(l => l.type === 'player' && l.prob >= 0.5);

      if (gameLegs.length >= 1 && playerLegs.length >= 2) {
        const balancedLegs = [
          ...gameLegs.sort((a, b) => b.prob - a.prob).slice(0, 1),
          ...playerLegs.sort((a, b) => b.prob - a.prob).slice(0, 2)
        ];
        const balanced = calculateParlayForLegs(balancedLegs);
        suggestions.push({
          name: 'Balanced Mix',
          legs: balancedLegs,
          prob: balanced.prob,
          odds: balanced.odds
        });
      }

      // Strategy 3: "Value" - best expected value
      const evLegs = availableLegs
        .map(l => ({
          ...l,
          ev: l.prob * (l.odds > 0 ? l.odds / 100 : 100 / Math.abs(l.odds))
        }))
        .filter(l => l.ev > 0.4)
        .sort((a, b) => b.ev - a.ev)
        .slice(0, 4);

      if (evLegs.length >= 3) {
        const valuePick = findBestCombination(evLegs, 3);
        if (valuePick) {
          suggestions.push({
            name: 'Value Play',
            legs: valuePick.legs,
            prob: valuePick.prob,
            odds: valuePick.odds
          });
        }
      }

      // Strategy 4: "Long Shot" - higher payout
      const longLegs = availableLegs
        .filter(l => l.prob >= 0.35 && l.prob <= 0.55 && l.odds > 0)
        .sort((a, b) => b.odds - a.odds)
        .slice(0, 3);

      if (longLegs.length >= 3) {
        const longShot = calculateParlayForLegs(longLegs);
        suggestions.push({
          name: 'Long Shot',
          legs: longLegs,
          prob: longShot.prob,
          odds: longShot.odds
        });
      }

      // Render suggestions
      if (suggestions.length === 0) {
        container.innerHTML = '<div class="no-data">Could not generate suggestions</div>';
        return;
      }

      container.innerHTML = suggestions.map((s, i) => `
        <div class="suggested-parlay" data-suggestion="${i}">
          <div class="suggested-header">
            <span class="suggested-name">${s.name}</span>
            <span class="suggested-odds">${formatOdds(s.odds)}</span>
          </div>
          <div class="suggested-legs">${s.legs.map(l => l.name).join(' + ')}</div>
          <div class="suggested-prob">${(s.prob * 100).toFixed(1)}% win probability</div>
        </div>
      `).join('');

      // Store for click handling
      window.suggestions = suggestions;

      container.querySelectorAll('.suggested-parlay').forEach(el => {
        el.addEventListener('click', () => {
          const idx = parseInt(el.dataset.suggestion);
          const suggestion = window.suggestions[idx];
          if (suggestion) {
            selectedLegs = [...suggestion.legs];
            renderLegs();
            renderSlip();
          }
        });
      });
    }

    function findBestCombination(legs, count) {
      // Find combination with best balance of probability and payout
      const combinations = getCombinations(legs, count);
      let best = null;
      let bestScore = -Infinity;

      combinations.forEach(combo => {
        const result = calculateParlayForLegs(combo);
        // Score: probability * log(odds) to balance both
        const score = result.prob * Math.log(Math.max(result.odds, 100));
        if (score > bestScore) {
          bestScore = score;
          best = { legs: combo, prob: result.prob, odds: result.odds };
        }
      });

      return best;
    }

    function getCombinations(arr, k) {
      const result = [];
      function combine(start, combo) {
        if (combo.length === k) {
          result.push([...combo]);
          return;
        }
        for (let i = start; i < arr.length; i++) {
          combo.push(arr[i]);
          combine(i + 1, combo);
          combo.pop();
        }
      }
      combine(0, []);
      return result;
    }

    function calculateParlayForLegs(legs) {
      let prob = 1;
      let decimal = 1;

      legs.forEach(leg => {
        prob *= leg.prob;
        decimal *= leg.odds > 0 ? (leg.odds / 100) + 1 : (100 / Math.abs(leg.odds)) + 1;
      });

      const odds = decimal >= 2
        ? Math.round((decimal - 1) * 100)
        : Math.round(-100 / (decimal - 1));

      return { prob, odds };
    }

    // Event listeners
    document.getElementById('matchup-select').addEventListener('change', (e) => {
      const val = e.target.value;
      if (!val) return;

      const [home, away, week] = val.split('|');
      selectedLegs = [];
      loadMatchupData(home, away, parseInt(week));
      renderSlip();
    });

    document.getElementById('clear-btn').addEventListener('click', () => {
      selectedLegs = [];
      renderLegs();
      renderSlip();
    });

    document.getElementById('wager-amount').addEventListener('input', () => {
      renderSlip();
    });

    // Initialize
    initDB().catch(err => {
      console.error(err);
      document.getElementById('legs-container').innerHTML =
        '<div class="no-data">Error loading database</div>';
    });
  </script>
</body>
</html>
